# Use nouns for <paths>, and verbs for <operationId>s.

# Use <$ref>s as much as practically possible to make smaller (and hence more readable) objects, and to allow OpenAPI
# Generator to give readable model names in the generated client SDKs.

# We only use a single OpenAPI file because the bulk of the code is in the <components> object, which cannot be split
# into multiple files because it'd be impractical to find the components to reuse.

# In the <components> object, name the schema the same as the request body or response it is for. The only exception is
# when a schema is reused in different request bodies or responses.

openapi: 3.0.3
info:
  title: Omni Chat
  version: '0.0.1'
  description: |
    Free, open core, federated chat system, to replace every existing chat app.

    To view the documentation for previos versions, see the
    [older releases](https://github.com/neelkamath/omni-chat/releases).

    Dates conform to ISO 8601.

    Here is the usual flow for using this service.
    1. Have the user sign up for an account. Pass the info they give you to create an account for them using the HTTP
      POST /user endpoint.
    1. Have the user verify their email.
    1. Have the user log in. Using the credentials they give you while logging in, request a JWT to authenticate their
      future actions by using the HTTP POST /jwt-request endpoint.
    1. Use the JWT to authorize requests on behalf of the user (e.g., to use the HTTP PATCH /user endpoint).
    1. Whenever required, refresh the JWT using the HTTP POST /jwt-refresh endpoint.
  contact:
    name: Neel Kamath
    email: neelkamathonline@gmail.com
    url: https://github.com/neelkamath/omni-chat
  license:
    name: MIT
    url: https://github.com/neelkamath/omni-chat/blob/master/LICENSE
servers:
  - url: http://localhost:80
    description: You'll have to run the server yourself.
security:
  - bearerAuth: []
paths:
  /email-verification:
    get:
      tags: [user]
      operationId: verifyEmail
      description: Sends the user an email to verify their email address.
      responses:
        '204':
          description: Verification email sent.
        '401':
          $ref: '#/components/responses/AuthorizationError'
  /health-check:
    get:
      tags: [status]
      security: []
      description: Checks if all systems are operational.
      operationId: checkHealth
      responses:
        '204':
          description: All systems are operational.
  /contacts:
    delete:
      tags: [contacts]
      description: Remove saved contacts. Invalid contacts (e.g., invalid user IDs, unsaved contacts) will be ignored.
      operationId: deleteContacts
      requestBody:
        $ref: '#/components/requestBodies/UserIdList'
      responses:
        '204':
          description: Contacts deleted.
        '401':
          $ref: '#/components/responses/AuthorizationError'
    get:
      tags: [contacts]
      description: Retrieve saved contacts.
      operationId: readContacts
      responses:
        '200':
          $ref: '#/components/responses/User'
        '401':
          $ref: '#/components/responses/AuthorizationError'
    post:
      tags: [contacts]
      description: Saves contacts. Contacts previously saved will be ignored. If the user's own contact is present, it
        will be ignored.
      operationId: createContacts
      requestBody:
        $ref: '#/components/requestBodies/UserIdList'
      responses:
        '204':
          description: Contacts saved.
        '400':
          description: At least one of the contacts were invalid, and so none of the users were saved. This might happen
            because a user whose contact was to be saved deleted their account just before the contacts were saved.
        '401':
          $ref: '#/components/responses/AuthorizationError'
  /jwt-request:
    post:
      tags: [jwt]
      security: []
      description: Endpoints such as HTTP PATCH /user require authentication via a JWT. You can acquire a JWT to
        authenticate a user by calling this endpoint with their credentials.
      operationId: requestJwt
      requestBody:
        $ref: '#/components/requestBodies/JwtRequest'
      responses:
        '200':
          $ref: '#/components/responses/Jwt'
        '400':
          description: A JWT couldn't be created.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/JwtRequestError'
  /jwt-refresh:
    post:
      tags: [jwt]
      description: Once the JWT has expired, the user would have to log in again. You can avoid this by requesting a new
        set of tokens using the refresh token you received with the JWT.
      operationId: refreshJwt
      requestBody:
        $ref: '#/components/requestBodies/RefreshJwt'
      responses:
        '200':
          $ref: '#/components/responses/Jwt'
  /user-search:
    get:
      tags: [search]
      description: Search users. You must send at least one of the query parameters.
      security: []
      operationId: searchUsers
      parameters:
        - in: query
          name: username
          schema:
            type: string
        - in: query
          name: first_name
          schema:
            type: string
        - in: query
          name: last_name
          schema:
            type: string
        - in: query
          name: email
          schema:
            type: string
      responses:
        '200':
          $ref: '#/components/responses/User'
        '400':
          description: At least one search filter must be used.
  /user:
    delete:
      tags: [user]
      description: Delete account.
      operationId: deleteUser
      responses:
        '204':
          description: Account deleted.
        '401':
          $ref: '#/components/responses/AuthorizationError'
    get:
      tags: [user]
      description: Get account details.
      operationId: readUser
      responses:
        '200':
          $ref: '#/components/responses/UserDetails'
        '401':
          $ref: '#/components/responses/AuthorizationError'
    patch:
      tags: [user]
      description: Update account.
      operationId: updateUser
      requestBody:
        $ref: '#/components/requestBodies/UserUpdate'
      responses:
        '204':
          description: Account updated
        '400':
          description: Account couldn't be updated.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UsernameTakenError'
        '401':
          $ref: '#/components/responses/AuthorizationError'
    post:
      tags: [user]
      security: []
      description: Creates an account, and sends them a verification email. The user will not be allowed to log in until
        they verify their email address.
      operationId: createUser
      requestBody:
        $ref: '#/components/requestBodies/NewUser'
      responses:
        '201':
          description: Account created
        '400':
          $ref: '#/components/responses/UsernameTakenError'
        '401':
          $ref: '#/components/responses/AuthorizationError'
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  schemas:
    Jwt:
      type: object
      example:
        jwt: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJjNDExNGUyOC1kN2M4LTQ5NjMtYTk4Yy01NThlMDgyNjljY2IiLCJhdWQiOiJvbW5pLWNoYXQiLCJpc3MiOiJodHRwOi8vYXV0aDo4MDgwIiwiZXhwIjoxNTg2MjM1ODkxfQ.7OpaHSmMsAe4TDWLr--ajFEHe9Ar1d9o4R7sygX3wTY
        expiry: 2020-04-07T05:04:51.830Z
        refresh_token: eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICI3MmM2NTE2ZS0zMGE1LTRkNTEtYmI1MS04NGU1NzFkM2Y0N2YifQ.eyJleHAiOjE1ODYyMzczOTEsImlhdCI6MTU4NjIzNTU5MSwianRpIjoiYTBlNmIwZDUtMjdlOC00YTljLWFjNDgtOTdjMDczMjE2ZDIwIiwiaXNzIjoiaHR0cDovL2F1dGg6ODA4MC9hdXRoL3JlYWxtcy9vbW5pLWNoYXQiLCJhdWQiOiJodHRwOi8vYXV0aDo4MDgwL2F1dGgvcmVhbG1zL29tbmktY2hhdCIsInN1YiI6ImM0MTE0ZTI4LWQ3YzgtNDk2My1hOThjLTU1OGUwODI2OWNjYiIsInR5cCI6IlJlZnJlc2giLCJhenAiOiJzZXJ2ZXIiLCJzZXNzaW9uX3N0YXRlIjoiNDBlNzhlYjAtOGZjOS00YzA1LWE2MjQtMDBiNDUwNGM5ODY1Iiwic2NvcGUiOiJwcm9maWxlIGVtYWlsIn0.kOJHHOAckmxJ9ymDNTan92HX8HmMkZJ28s6VdTjfe88
        refresh_token_expiry: 2020-04-07T05:29:51.852Z
      properties:
        jwt:
          type: string
          description: The JWT to send with requests requiring authentication
        expiry:
          type: string
          description: When the JWT expires
        refresh_token:
          type: string
          description: The JWT is short-lived. Once it expires, the user would have to log in again. This can be avoided
            by passing the refresh token to the HTTP POST /jwt_refresh endpoint to request a new set of tokens.
        refresh_token_expiry:
          type: string
          description: When the refresh token expires
      required: [jwt, expiry, refresh_token, refresh_token_expiry]
    JwtRequestError:
      type: object
      example:
        reason: NONEXISTENT_USER
      properties:
        reason:
          type: string
          enum: [NONEXISTENT_USER, EMAIL_NOT_VERIFIED, INCORRECT_PASSWORD]
      required: [reason]
    Login:
      type: object
      example:
        username: johndoe@example.com
        password: pass
      properties:
        username:
          type: string
        password:
          type: string
      required: [username, password]
    NewUser:
      type: object
      example:
        username: johndoe
        password: pass
        email: johndoe@example.com
        first_name: John
        last_name: Doe
      properties:
        username:
          type: string
        password:
          type: string
        email:
          type: string
        first_name:
          type: string
        last_name:
          type: string
      required: [username, password, email]
    RefreshJwt:
      type: object
      properties:
        refresh_token:
          type: string
          description: The refresh token you got with the JWT
      required: [refresh_token]
    User:
      type: object
      example:
        users:
          - user_id: 44778d05-0304-47cf-be61-50225e04a1c7
            username: john_doe
            email: john.doe@example.com
            first_name: John
            last_name: Doe
      properties:
        users:
          type: array
          items:
            type: object
            properties:
              user_id:
                type: string
              username:
                type: string
              email:
                type: string
              first_name:
                type: string
              last_name:
                type: string
            required: [user_id, username]
      required: [users]
    UserDetails:
      type: object
      example:
        user_id: 44778d05-0304-47cf-be61-50225e04a1c7
        username: john_doe
        email: john.doe@example.com
        first_name: John
        last_name: Doe
      properties:
        user_id:
          type: string
        username:
          type: string
        email:
          type: string
        first_name:
          type: string
        last_name:
          type: string
      required: [user_id, username, email]
    UserIdList:
      type: object
      example:
        user_id_list: [44778d05-0304-47cf-be61-50225e04a1c7, 524a6b24-1ab2-48a1-9c0e-26bd19662ad3]
      properties:
        user_id_list:
          type: array
          items:
            type: string
      required: [user_id_list]
    UsernameTakenError:
      type: object
      example:
        reason: USERNAME_TAKEN
      properties:
        reason:
          type: string
          enum: [USERNAME_TAKEN]
      required: [reason]
    UserUpdate:
      type: object
      example:
        email: john.rogers@example.com
        last_name: Rogers
      properties:
        username:
          type: string
        password:
          type: string
        email:
          type: string
          description: Changing the email address will require the user to verify their new address. If the user
            requested that their address be updated, and the server successfully updates it, then you should log the
            user out. This is because your current refresh token won't work since the user's account is disabled until
            they verify their address. This means that they will have to contact an admin to reset their address in
            case they entered an incorrect address.
        first_name:
          type: string
        last_name:
          type: string
  requestBodies:
    JwtRequest:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Login'
    NewUser:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/NewUser'
    RefreshJwt:
      required: true
      content:
        application/x-www-form-urlencoded:
          schema:
            $ref: '#/components/schemas/RefreshJwt'
    UserIdList:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/UserIdList'
    UserUpdate:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/UserUpdate'
  responses:
    AuthorizationError:
      description: Access token is missing or invalid
    Jwt:
      description: Token set
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Jwt'
    User:
      description: Users.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/User'
    UserDetails:
      description: Account details.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/UserDetails'
    UsernameTakenError:
      description: The user couldn't be created.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/UsernameTakenError'