"""Complies with ISO 8601."""
scalar DateTime

"""A cursor for pagination."""
scalar Cursor

"""
A username must be 1-30 characters long. Only lowercase English letters (a-z), English numbers (0-9), periods, and
underscores are allowed.
"""
scalar Username

"""A name must neither contain whitespace nor exceed 30 characters."""
scalar Name

"""
A user's bio which cannot exceed 2,500 characters, and uses GitHub Flavored Markdown. Leading and trailing whitespace is
disallowed.
"""
scalar Bio

"""A password which contains non-whitespace characters."""
scalar Password

"""1-70 characters, of which at least one isn't whitespace. Leading and trailing whitespace is disallowed."""
scalar GroupChatTitle

"""At most 1,000 characters, and uses GitHub Flavored Markdown. Leading and trailing whitespace is disallowed."""
scalar GroupChatDescription

"""
1-10,000 characters, of which at least one isn't whitespace. Uses GitHub Flavored Markdown. Leading and trailing
whitespace is disallowed.
"""
scalar MessageText

scalar Uuid

"""
GraphQL mandates data be returned for every operation, and data be present in every type. However, certain operations
and types don't have relevant data. This type, which is an empty `String`, indicates such.
"""
scalar Placeholder

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

type Query {
    """
    Returns the user's starred messages.

    An access token must be sent with this request.
    """
    readStars(first: Int, after: Cursor): StarredMessagesConnection!

    """
    Returns users blocked by this user.

    An access token must be sent with this request.
    """
    readBlockedUsers(first: Int, after: Cursor): AccountsConnection!

    """
    Whether the `userId` is online. If the `userId` exists, an `OnlineStatus` will be returned. Otherwise, an
    `InvalidUserId` will be returned.
    """
    readOnlineStatus(userId: Int!): ReadOnlineStatusResult!

    """
    The users who are typing in a chat the user is in. The user's own status won't be returned.

    An access token must be sent with this request.
    """
    readTypingUsers: [TypingUsers!]!

    """
    Case-insensitively `query`s text messages, poll message title and options, action message text and actions, and pic
    message captions in the `chatId`. The returned `MessageEdge`s are chronologically ordered.

    A returned `InvalidChatId` indicates that the chat isn't public, and the user isn't in the chat.

    An access token must be sent with this request if the `chatId` isn't a public chat.
    """
    searchChatMessages(chatId: Int!, query: String!, last: Int, before: Cursor): SearchChatMessagesResult!

    """
    Case-insensitively `query`s every text message, poll message's title and options, action message's text and actions,
    and pic message's caption in every chat the user is in. Each item in the returned `ChatMessages` will be for a
    particular `ChatMessages.chat`, and have the `ChatMessages.messages` from the search results. Each chat's messages
    are chronologically ordered.

    An access token must be sent with this request.
    """
    searchMessages(query: String!, first: Int, after: Cursor): ChatMessagesConnection!

    """
    Returns the user's account info.

    An access token must be sent with this request.
    """
    readAccount: Account!

    """
    Returns the chats the user is in.

    An access token must be sent with this request.
    """
    readChats(first: Int, after: Cursor): ChatsConnection!

    """An access token must be sent with this request if the chat being read isn't a public chat."""
    readChat(id: Int!): ReadChatResult!

    """
    Returns the `GroupChatInfo` the `inviteCode` is for. This could be used to display a chat the user isn't in but was
    invited to, so that they can check whether they'd like to join.
    """
    readGroupChat(inviteCode: Uuid!): ReadGroupChatResult!

    """
    Case-insensitively searches group chats and private chats the user is in. Private chats are searched by matching the
    `query` with the username, first name, and last name of users the user has chats with. Group chats are searched by
    matching the `query` with the title of group chats the user is in.

    An access token must be sent with this request.
    """
    searchChats(query: String!): [Chat!]!

    """Searches chats by case-insensitively `query`ing their titles."""
    searchPublicChats(query: String!): [GroupChat!]!

    """
    Retrieves saved contacts.

    An access token must be sent with this request.
    """
    readContacts(first: Int, after: Cursor): AccountsConnection!

    """
    Case-insensitively searches contacts by `query`ing their usernames, first names, last names, and email addresses.

    An access token must be sent with this request.
    """
    searchContacts(query: String!, first: Int, after: Cursor): AccountsConnection!

    """
    Operations such as `Query.updateAccount` require authentication via an access token. An access token can be acquired
    by passing the user's `Login` to this operation. Once the access token has expired, the `TokenSet.refreshToken` can
    be passed to `Query.refreshTokenSet`.
    """
    requestTokenSet(login: Login!): RequestTokenSetResult!

    """
    The access token is short-lived. Once it expires, the user would have to log in again. This can be avoided by
    passing the `TokenSet.refreshToken` from `Query.requestTokenSet` as the `refreshToken` to request a new `TokenSet`.
    """
    refreshTokenSet(refreshToken: ID!): TokenSet!

    """
    Searches users. The `query` is case-insensitively matched against users' usernames, email addresses, first names,
    and last names. Returns the users found.
    """
    searchUsers(query: String!, first: Int, after: Cursor): AccountsConnection!

    """
    Searches blocked users. The `query` is case-insensitively matched against users' usernames, email addresses, first
    names, and last names. Returns the users found.

    An access token must be sent with this request.
    """
    searchBlockedUsers(query: String!, first: Int, after: Cursor): AccountsConnection!
}

type Mutation {
    """
    Blocks the `id`. Does nothing if the user has already been blocked, or the user is blocking themselves.`null` will
    be returned if the operation succeeded.

    An access token must be sent with this request.
    """
    blockUser(id: Int!): InvalidUserId

    """
    Unblocks the `id`. Returns `true` if the user got unblocked. Returns `false` if either the user wasn't blocked or
    the `id` doesn't exist.

    An access token must be sent with this request.
    """
    unblockUser(id: Int!): Boolean!

    """
    Deletes the user's account. All the user's data will be wiped from the system. This means that users in private
    chats with the user will have their chats deleted, etc. `null` will be returned if the account was deleted.

    An access token must be sent with this request.
    """
    deleteAccount: CannotDeleteAccount

    """
    When a user creates an account, or updates their email address, they'll receive an email with a `verificationCode`
    which must be passed to this operation in order to verify their email address. If the `verificationCode` is valid,
    the account's email address verification status will be set to verified, and `null` will be returned. Use
    `Mutation.emailEmailAddressVerification` if the user lost their verification code.
    """
    verifyEmailAddress(emailAddress: String!, verificationCode: Int!): VerifyEmailAddressResult

    """
    Updates the password of the account associated with the `emailAddress` to the `newPassword` if the
    `passwordResetCode` is correct, and returns `null`.
    """
    resetPassword(emailAddress: String!, passwordResetCode: Int!, newPassword: Password!): ResetPasswordResult

    """
    Stars the `messageId`. The user can star their own messages. Starring an already starred message will do nothing.
    `null` will be returned if the operation succeeded. An `InvalidMessageId` will be returned if the message doesn't
    exist.

    An access token must be sent with this request.
    """
    star(messageId: Int!): InvalidMessageId

    """
    Unstars the `messageId`. Does nothing if the message wasn't starred.

    An access token must be sent with this request.
    """
    unstar(messageId: Int!): Placeholder!

    """
    Sets the current user's status to `isOnline`.

    An access token must be sent with this request.
    """
    setOnline(isOnline: Boolean!): Placeholder!

    """
    Sets whether the user `isTyping` in the `chatId`. `null` will be returned if the operation succeeded. An
    `InvalidChatId` will be returned if the user isn't in the chat.

    Let's consider an example use case. Once the user starts typing, the other users in the chat will see a typing
    status on the user. Once the user stops typing for more than two seconds, the typing status will be removed.

    An access token must be sent with this request.
    """
    setTyping(chatId: Int!, isTyping: Boolean!): InvalidChatId

    """
    Deletes the user's profile pic.

    An access token must be sent with this request.
    """
    deleteProfilePic: Placeholder!

    """
    Deletes the group chat's profile pic. The user must be the admin.

    An access token must be sent with this request.
    """
    deleteGroupChatPic(chatId: Int!): Placeholder!

    """
    Records that the user received or read the `messageId`. If the `status` is `MessageStatus.READ`, and there's no
    `MessageStatus.DELIVERED` record, the delivery status will be created. Nothing will happen if the status was already
    created.

    `null` will be returned if the operation succeeded. An `InvalidMessageId` will be returned if either the message
    doesn't exist in a chat the user is in or the message is the user's own.

    An access token must be sent with this request.
    """
    createStatus(messageId: Int!, status: MessageStatus!): InvalidMessageId

    """
    Updates the user's account. Only the non-null fields will be updated. None of the updates will take place if even
    one of the fields were invalid. If the user updates their email address to something other than their current
    address, they must be loged out because the current access token will be invalid until they verify their new email
    address. `null` will be returned if the operation succeeded.

    If the user updates their email address, they'll be required to verify it before their next login via an email which
    is sent to it. This means they'll be locked out of their account if they provide an invalid address, and will have
    to contact the service's admin to correctly update their address. This mistake can be prevented by asking them to
    confirm their address. For example, a UI could require the user to enter their email address twice if they're
    updating it, and only allow the update to take place if both the entered addresses match.

    An access token must be sent with this request.
    """
    updateAccount(update: AccountUpdate!): UpdateAccountResult

    """
    Creates an account, and sends the user a verification email. The user will not be allowed to log in until they
    verify their email address. Use `Mutation.verifyEmailAddress` to verify the user's email address. `null` will be
    returned if the operation succeeded.
    """
    createAccount(account: AccountInput!): CreateAccountResult

    """
    Sends the user an email to verify their `emailAddress`. An example use case for this operation is when the user
    created an account (which caused an email address verification email to be sent) but accidentally deleted the email,
    and therefore requires it to be resent. `null` will be returned if the operation succeeded.
    """
    emailEmailAddressVerification(emailAddress: String!): EmailEmailAddressVerificationResult

    """
    Sends a password reset email to the supplied `emailAddress`. The email will contain a password reset code which must
    then be passed to `Mutation.resetPassword`. If the user is logged in (i.e., an access token is present), and wants
    to update their password, `Mutation.updateAccount` should be used instead. `null` will be returned if the operation
    succeeded.
    """
    emailPasswordResetCode(emailAddress: String!): UnregisteredEmailAddress

    """An access token must be sent with this request. Only an admin can perform this operation."""
    updateGroupChatTitle(chatId: Int!, title: GroupChatTitle!): Placeholder!

    """An access token must be sent with this request. Only an admin can perform this operation."""
    updateGroupChatDescription(chatId: Int!, description: GroupChatDescription!): Placeholder!

    """
    Nonexistent users, and users who are already in the chat will be ignored.

    An access token must be sent with this request. Only an admin can perform this operation.
    """
    addGroupChatUsers(chatId: Int!, idList: [Int!]!): Placeholder!

    """
    Messages sent by, and polls voted on, by removed users will remain. Nonexistent users, and users who aren't in the
    chat will be ignored. Every message a removed user had starred in the specified chat will be unstarred for them.
    `null` will be returned if the operation succeeded.

    An access token must be sent with this request. Only an admin can perform this operation.
    """
    removeGroupChatUsers(chatId: Int!, idList: [Int!]!): CannotLeaveChat

    """
    Leaves the chat the user is in. Every message the user has starred in the specified chat will be unstarred for them.

    Returns `null` if the operation succeeded. An `InvalidChatId` will be returned if the user isn't the specified group
    chat.

    An access token must be sent with this request.
    """
    leaveGroupChat(chatId: Int!): LeaveGroupChatResult

    """
    Makes every user in the `idList` an admin of the `chatId`. Nonexistent users, users who aren't in the chat, and
    users who are already admins, are ignored.

    An access token must be sent with this request. Only an admin can perform this operation.
    """
    makeGroupChatAdmins(chatId: Int!, idList: [Int!]!): Placeholder!

    """
    Creates a group chat. Nonexistent users are ignored. The `chat` parameter's `GroupChatInput.userIdList` and
    `GroupChatInput.adminIdList` needn't contain the user's own ID, as it is implicitly included.

    If an `InvalidAdminId` is returned, it indicates that the `chat` parameter's `GroupChatInput.adminIdList` wasn't a
    subset of the `GroupChatInput.userIdList`.

    An access token must be sent with this request.
    """
    createGroupChat(chat: GroupChatInput!): CreateGroupChatResult!

    """
    Sets whether the `chatId` `isBroadcast`. The user must be an admin to perform this operation.

    An access token must be sent with this request.
    """
    setBroadcast(chatId: Int!, isBroadcast: Boolean!): Placeholder!

    """
    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the chat isn't a group
    chat, or the chat is a public chat.

    An access token must be sent with this request. The user must be an admin to perform this operation.
    """
    setInvitability(chatId: Int!, isInvitable: Boolean!): InvalidChatId

    """
    Joins the chat the `inviteCode` is for. Nothing will happen if the user is already in the chat. `null` will be
    returned if the operation succeeded. You can easily join a public chat using `Mutation.joinPublicChat`.

    An access token must be sent with this request.
    """
    joinGroupChat(inviteCode: Uuid!): InvalidInviteCode

    """
    Joins the specified public chat. Nothing will happen if the user is already in the chat. `null` will be returned if
    the operation succeeded. An `InvalidChatId` will be returned if there's no such public chat.

    An access token must be sent with this request.
    """
    joinPublicChat(chatId: Int!): InvalidChatId

    """
    Deletes a private chat.  Any messages the user starred in the chat will be unstarred.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the user isn't in the
    chat.

    An access token must be sent with this request.
    """
    deletePrivateChat(chatId: Int!): InvalidChatId

    """
    Creates a private chat with the `userId` unless the chat already exists. In either case, the chat's ID will be
    returned. A returned `InvalidUserId` indicates that the specified user doesn't exist.

    An access token must be sent with this request.
    """
    createPrivateChat(userId: Int!): CreatePrivateChatResult!

    """
    Sends the `text` in the `chatId`. If the `chatId` is a broadcast chat, the user must be an admin to message. The
    user might want to give their message a context, such as when replying to a message sent several messages ago. In
    this case, the `contextMessageId` is to be the ID of the message being replied to.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the user isn't in the
    chat. An `InvalidMessageId` will be returned if the `contextMessageId` doesn't exist.

    An access token must be sent with this request.
    """
    createTextMessage(chatId: Int!, text: MessageText!, contextMessageId: Int): CreateTextMessageResult

    """
    Sends the `text` in the `chatId`. For example, a restaurant's bot asks if the user wants a burger or a pizza in the
    `text`, and the `actions` are `"burger"` and `"pizza"`. If the `chatId` is a broadcast chat, the user must be an
    admin to message. The user might want to give their message a context, such as when replying to a message sent
    several messages ago. In this case, the `contextMessageId` is to be the ID of the message being replied to.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the user isn't in the
    chat. An `InvalidAction` will be returned if either there were zero `actions` or the `actions` weren't unique. An
    `InvalidMessageId` will be returned if the `contextMessageId` doesn't exist.

    A frontend UI could display this message like a regular text message but with buttons below it. Action messages are
    meant for bots; human users shouldn't be able to create them. Only the creator of the action message will be
    notified when `Mutation.triggerAction` gets called.

    An access token must be sent with this request.
    """
    createActionMessage(chatId: Int!, message: ActionMessageInput!, contextMessageId: Int): CreateActionMessageResult

    """
    Creates a `GroupChatInviteMessage` in the `chatId` inviting users to join the `invitedChatId`. If the `chatId` is a
    broadcast chat, the user must be an admin to message. The user might want to give their message a context, such as
    when replying to a message sent several messages ago. In this case, the `contextMessageId` is to be the ID of the
    message being replied to. A frontend UI might want to hide the `GroupChatInviteMessage.inviteCode`, and instead
    display the `GroupChatInfo` returned by `Query.readGroupChat`.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the user isn't in the
    `chatId`. An `InvalidInvitedChat` will be returned if the `invitedChatId` isn't a group chat, or the chat has
    turned off invitations. An `InvalidMessageId` will be returned if the `contextMessageId` doesn't exist.

    An access token must be sent with this request.
    """
    createGroupChatInviteMessage(
        chatId: Int!
        invitedChatId: Int!
        contextMessageId: Int
    ): CreateGroupChatInviteMessageResult

    """
    Sends the `poll` in the `chatId`. If the `chatId` is a broadcast chat, the user must be an admin to message. The
    user might want to give their message a context, such as when replying to a message sent several messages ago. In
    this case, the `contextMessageId` is to be the ID of the message being replied to.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the user isn't in the
    chat. An `InvalidMessageId` will be returned if the `contextMessageId` doesn't exist.

    An access token must be sent with this request.
    """
    createPollMessage(chatId: Int!, poll: PollInput!, contextMessageId: Int): CreatePollMessageResult

    """
    Forwards the `messageId` to the `chatId`. If the `chatId` is a broadcast chat, the user must be an admin to message.
    The user might want to give their message a context, such as when replying to a message sent several messages ago.
    In this case, the `contextMessageId` is to be the ID of the message being replied to.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the user isn't in the
    chat. An `InvalidMessageId` will be returned if the `messageId` or `contextMessageId` doesn't exist.

    An access token must be sent with this request.
    """
    forwardMessage(chatId: Int!, messageId: Int!, contextMessageId: Int): ForwardMessageResult

    """
    Triggers the `action` on the `messageId`'s action message.

    `null` will be returned if the operation succeeded. An `InvalidMessageId` will be returned if there's no such action
    message. An `InvalidAction` will be returned if the `action` doesn't exist.

    An access token must be sent with this request.
    """
    triggerAction(messageId: Int!, action: MessageText!): TriggerActionResult

    """
    Updates the user's vote for the `option` on the `messageId`'s poll. If `vote` is `true`, the user's vote will be
    added if it hasn't already. If `vote` is `false`, the user's vote will be removed if there is one.

    `null` will be returned if the operation succeeded. An `InvalidMessageId` will be returned if there's no such poll
    message.

    An access token must be sent with this request.
    """
    setPollVote(messageId: Int!, option: MessageText!, vote: Boolean!): SetPollVoteResult

    """
    Deletes the message `id` from the chat it's from. The user can only delete their own messages.

    `null` will be returned if the operation succeeded. An `InvalidMessageId` will be returned if the message isn't in a
    chat the user is in, the message isn't visible to the user because they deleted the private chat, or the message
    isn't the user's own.

    An access token must be sent with this request.
    """
    deleteMessage(id: Int!): InvalidMessageId

    """
    Deletes the specified user from the user's contacts. Returns `true` if the contact got deleted. Returns `false` if
    the `id` was either not a contact or a nonexistent user ID.

    An access token must be sent with this request.
    """
    deleteContact(id: Int!): Boolean!

    """
    Saves the `id` as a contact. Returns `true` if the contact got saved. Returns `false` if the `id` was either a
    preexisting contact or a nonexistent user ID.

    An access token must be sent with this request.
    """
    createContact(id: Int!): Boolean!
}

type Subscription {
    """
    Yields created, updated, and deleted messages (including the user's own messages) in every chat the user is in. A
    message from a chat the user wasn't previously in can be sent as well (e.g., when the other user in a private chat
    the user deleted sends a message in it). The subscription will be stopped if the user deletes their account.

    An access token must be sent with this request.
    """
    subscribeToMessages: MessagesSubscription!

    """
    Yields the online statuses of users the user has in their contacts, or has a chat with. The subscription will be
    stopped if the user deletes their account.

    An access token must be sent with this request.
    """
    subscribeToOnlineStatuses: OnlineStatusesSubscription!

    """
    Yields typing statuses for chats the user has. The user's own typing statuses won't be yielded. The subscription
    will be stopped if the user deletes their account.

    An access token must be sent with this request.
    """
    subscribeToTypingStatuses: TypingStatusesSubscription!

    """
    Yields updates on the user's contacts, the subscriber's account, and accounts of users the subscriber has a chat
    with. The subscription will be stopped if the user deletes their account.

    An access token must be sent with this request.
    """
    subscribeToAccounts: AccountsSubscription!

    """
    Yields group chats the user was added to (including chats they created), and group chat metadata updates. The
    subscription will be stopped if the user deletes their account.

    An access token must be sent with this request.
    """
    subscribeToGroupChats: GroupChatsSubscription!
}

union MessagesSubscription =
    | CreatedSubscription
    | NewTextMessage
    | NewActionMessage
    | NewPicMessage
    | NewAudioMessage
    | NewGroupChatInviteMessage
    | NewDocMessage
    | NewVideoMessage
    | NewPollMessage
    | UpdatedMessage
    | TriggeredAction
    | DeletedMessage
    | MessageDeletionPoint
    | DeletionOfEveryMessage
    | UserChatMessagesRemoval
    | UnstarredChat

"""Every message in the chat has been unstarred by the user."""
type UnstarredChat {
    id: Int!
}

union OnlineStatusesSubscription = CreatedSubscription | OnlineStatus

union TypingStatusesSubscription = CreatedSubscription | TypingStatus

"""
A user will be automatically unblocked when they delete their account. In this scenario, an `UnblockedAccount` will not
be sent because it's a rare event, and the client would've had to deal with the user viewing a user who's account was
just deleted.
"""
union AccountsSubscription =
    | CreatedSubscription
    | NewContact
    | UpdatedAccount
    | UpdatedProfilePic
    | DeletedContact
    | BlockedAccount
    | UnblockedAccount
    | DeletedAccount

"""The `id` of the user who deleted their account."""
type DeletedAccount {
    id: Int!
}

"""The `id` of the user who updated their profile pic."""
type UpdatedProfilePic {
    id: Int!
}

"""
A `GroupChatId` is the ID of the chat the user was added to.

If the subscriber leaves the chat, they will receive their own `ExitedUsers` message.
"""
union GroupChatsSubscription = CreatedSubscription | GroupChatId | UpdatedGroupChatPic |  UpdatedGroupChat | ExitedUsers

"""The `id` of the group chat whose pic was updated."""
type UpdatedGroupChatPic {
    id: Int!
}

"""
The `action` on the action `messageId` which was `triggeredBy` the user. This will only be sent to the user who created
the action message.
"""
type TriggeredAction {
    messageId: Int!
    action: MessageText!
    triggeredBy: Account!
}

type OnlineStatus {
    userId: Int!
    isOnline: Boolean!
    """`null` if the `userId` has never set an online status."""
    lastOnline: DateTime
}

"""Whether the `userId` `isTyping` in the `chatId`."""
type TypingStatus {
    chatId: Int!
    userId: Int!
    isTyping: Boolean!
}

"""The `users` who are typing in the `chatId`."""
type TypingUsers {
    chatId: Int!
    users: [Account!]!
}

type GroupChatId {
    id: Int!
}

"""The users who left the group chat."""
type ExitedUsers {
    chatId: Int!
    userIdList: [Int!]!
}

"""null fields correspond to the field not existing. This will not be sent if the profile pic was updated."""
type UpdatedAccount {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""
Null fields haven't been updated. If a non-null field hasn't been updated, its value will be the same as before. This
will not be sent if the pic has been updated.
"""
type UpdatedGroupChat {
    chatId: Int!
    title: GroupChatTitle
    description: GroupChatDescription
    newUsers: [Account!]
    removedUsers: [Account!]
    adminIdList: [Int!]
    isBroadcast: Boolean
    publicity: GroupChatPublicity
}

"""
Every message in the `chatId` has been deleted.

This happens in private chats when the user deleted it, or the other user deleted their account. This happens in group
chats when the last user left the chat.
"""
type DeletionOfEveryMessage {
    chatId: Int!
}

"""
Every message the `userId` sent in the `chatId` has been deleted. This happens when a group chat's member deletes their
account.
"""
type UserChatMessagesRemoval {
    chatId: Int!
    userId: Int!
}

"""
Indicates that the `Subscription` has been created. This will only be sent only once, and will be the first event sent.
"""
type CreatedSubscription {
    placeholder: Placeholder!
}

"""Indicates that the every message `until` the `DateTime` has been deleted in the `chatId`."""
type MessageDeletionPoint {
    chatId: Int!
    until: DateTime!
}

"""The `messageId` has been deleted from the `chatId`."""
type DeletedMessage {
    chatId: Int!
    messageId: Int!
}

input PollInput {
    """For example, `"Where should we meet?"`."""
    title: MessageText!
    """There must be at least two options. Each option must be unique. For example, `["Burger King", "Pizza Hut"]`."""
    options: [MessageText!]!
}

type PollOption {
    option: MessageText!
    """The ID of every user who voted for this."""
    votes: [Int!]!
}

"""A user can vote for each option at most once, but can vote for multiple options."""
type Poll {
    title: MessageText!
    """There are at least two options, each of which are unique."""
    options: [PollOption!]!
}

input ActionMessageInput {
    """For example, `"What would you like to order?"`."""
    text: MessageText!
    """There must be at least one action. Each action must be unique. For example, `["Pizza", "Burger"]`."""
    actions: [MessageText!]!
}

type ActionableMessage {
    text: MessageText!
    """There's at least one action. Each action is unique."""
    actions: [MessageText!]!
}

type ChatsConnection {
    edges: [ChatEdge!]!
    pageInfo: PageInfo!
}

type ChatEdge {
    node: Chat!
    cursor: Cursor!
}

type AccountsConnection {
    edges: [AccountEdge!]!
    pageInfo: PageInfo!
}

type AccountEdge {
    node: Account!
    cursor: Cursor!
}

interface AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

type Account implements AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""A blocked user."""
type BlockedAccount implements AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""The user `id` of an unblocked user."""
type UnblockedAccount {
    id: Int!
}

type NewContact implements AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""
The `id` of the contact which has been deleted for the user. This happens when the user deletes a contact, or the
contact's account gets deleted.
"""
type DeletedContact {
    id: Int!
}

input AccountInput {
    username: Username!
    password: Password!
    emailAddress: String!
    firstName: Name! = ""
    lastName: Name! = ""
    bio: Bio! = ""
}

type ChatMessagesConnection {
    edges: [ChatMessagesEdge!]!
    pageInfo: PageInfo!
}

type ChatMessagesEdge {
    node: ChatMessages!
    cursor: Cursor!
}

type ChatMessages {
    chat: Chat!
    messages(last: Int, before: Cursor): [MessageEdge!]!
}

interface Chat {
    id: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
}

type MessagesConnection {
    edges: [MessageEdge!]!
    pageInfo: PageInfo!
}

type StarredMessagesConnection {
    edges: [StarredMessageEdge!]!
    pageInfo: PageInfo!
}

type StarredMessageEdge {
    node: StarredMessage!
    cursor: Cursor!
}

type MessageEdge {
    node: Message!
    cursor: Cursor!
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: Cursor
    endCursor: Cursor
}

interface BareGroupChat {
    title: GroupChatTitle!
    description: GroupChatDescription!
    """The ID of the `users` who are the admins. There will be at least one admin."""
    adminIdList: [Int!]!
    users(first: Int, after: Cursor): AccountsConnection!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
}

type GroupChatInfo implements BareGroupChat {
    title: GroupChatTitle!
    description: GroupChatDescription!
    adminIdList: [Int!]!
    users(first: Int, after: Cursor): AccountsConnection!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
}

type GroupChat implements Chat, BareGroupChat {
    id: Int!
    title: GroupChatTitle!
    description: GroupChatDescription!
    adminIdList: [Int!]!
    users(first: Int, after: Cursor): AccountsConnection!
    messages(last: Int, before: Cursor): MessagesConnection!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
    """null if invite codes are turned off."""
    inviteCode: Uuid
}

type PrivateChat implements Chat {
    id: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
    """The user being chatted with."""
    user: Account!
}

type MessageContext {
    """Whether this message was in reply to a particular message."""
    hasContext: Boolean!
    """
    The ID of the context message.

    If this message doesn't `hasContext`, this will be null. If this message `hasContext`, this will be null only if the
    context message was deleted. Since this message might not make any sense without the context, if this message
    `hasContext`, but the context message was deleted, a frontend could replace what should've been the context message
    with something similar to "Message deleted".
    """
    id: Int
}

interface BareMessage {
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

interface Message implements BareMessage {
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

type TextMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    textMessage: MessageText!
}

type ActionMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    actionableMessage: ActionableMessage!
}

type PicMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    caption: MessageText
}

type PollMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    poll: Poll!
}

type AudioMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

type GroupChatInviteMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    inviteCode: Uuid!
}

type DocMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

type VideoMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

interface BareChatMessage implements BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

"""The message which the user starred."""
interface StarredMessage implements BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type StarredTextMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    textMessage: MessageText!
}

type StarredActionMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    actionableMessage: ActionableMessage!
}

type StarredPicMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    caption: MessageText
}

type StarredPollMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    poll: Poll!
}

type StarredAudioMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type StarredGroupChatInviteMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    inviteCode: Uuid!
}

type StarredDocMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type StarredVideoMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

interface NewMessage implements BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type NewTextMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    textMessage: MessageText!
}

type NewActionMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    actionableMessage: ActionableMessage!
}

type NewPicMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    caption: MessageText
}

type NewPollMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    poll: Poll!
}

type NewAudioMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type NewGroupChatInviteMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    inviteCode: Uuid!
}

type NewDocMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type NewVideoMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

"""An existing `messageId` in the `chatId` which has been updated."""
type UpdatedMessage {
    chatId: Int!
    messageId: Int!
    state: MessageState!
    statuses: [MessageDateTimeStatus!]!
    hasStar: Boolean!
}

type MessageDateTimes {
    sent: DateTime!
    statuses: [MessageDateTimeStatus!]!
}

"""The `dateTime` the `user` created the `status`."""
type MessageDateTimeStatus {
    user: Account!
    dateTime: DateTime!
    status: MessageStatus!
}

enum MessageState {
    """Each user in the chat hasn't had the message delivered to them yet."""
    SENT
    """Each user in the chat has had the message delivered to them but not everyone has read it yet."""
    DELIVERED
    """Each user in the chat has read the message."""
    READ
}

enum MessageStatus {
    DELIVERED
    READ
}

enum GroupChatPublicity {
    """Users cannot join the chat via an invite code."""
    NOT_INVITABLE
    """Users can join the chat via an invite code."""
    INVITABLE
    """
    People can search for, and view public chats without an account. Invite codes are permanently turned on. Anyone
    with an account can join a public chat. A frontend UI may allow for a search engine to index the chat should the
    administrator allow for it. A chat must be made public when it's being created because chats can't switch between
    being public after they've been created.
    """
    PUBLIC
}

type TokenSet {
    accessToken: ID!
    refreshToken: ID!
}

input Login {
    username: Username!
    password: Password!
}

"""Only non-null fields will be updated."""
input AccountUpdate {
    username: Username
    password: Password
    emailAddress: String
    firstName: Name
    lastName: Name
    bio: Bio
}

input GroupChatInput {
    title: GroupChatTitle!
    description: GroupChatDescription!
    userIdList: [Int!]!
    adminIdList: [Int!]!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
}

"""The username doesn't exist."""
type NonexistentUser {
    placeholder: Placeholder!
}

type UnverifiedEmailAddress {
    placeholder: Placeholder!
}

"""The email address is already verified."""
type EmailAddressVerified {
    placeholder: Placeholder!
}

type UsernameTaken {
    placeholder: Placeholder!
}

type IncorrectPassword {
    placeholder: Placeholder!
}

type EmailAddressTaken {
    placeholder: Placeholder!
}

type InvalidChatId {
    placeholder: Placeholder!
}

type InvalidAdminId {
    placeholder: Placeholder!
}

type UnregisteredEmailAddress {
    placeholder: Placeholder!
}

type InvalidUserId {
    placeholder: Placeholder!
}

type InvalidMessageId {
    placeholder: Placeholder!
}

"""
The only reason the account cannot be deleted is if the user is the only admin of a group chat containing users other
than themselves. In this case, they must first appoint a different user as an admin.
"""
type CannotDeleteAccount {
    placeholder: Placeholder!
}

"""There were fewer than two options, or an option was duplicated."""
type InvalidPoll {
    placeholder: Placeholder!
}

"""The option isn't in the poll."""
type NonexistentOption {
    placeholder: Placeholder!
}

type InvalidInviteCode {
    placeholder: Placeholder!
}

"""Either the invited isn't a group chat or the chat has turned off invitations."""
type InvalidInvitedChat {
    placeholder: Placeholder!
}

"""
This Omni Chat instance disallows the provided email address's domain. For example, `"john.doe@private.company.com"` may
be allowed, but not `"john.doe@gmail.com"`.
"""
type InvalidDomain {
    placeholder: Placeholder!
}

type InvalidAction {
    placeholder: Placeholder!
}

type MessageEdges {
    edges: [MessageEdge!]!
}

type InvalidVerificationCode {
    placeholder: Placeholder!
}

type InvalidPasswordResetCode {
    placeholder: Placeholder!
}

type CreatedChatId {
    id: Int!
}

"""
The user attempted to leave the chat but they must first appoint another user as an admin because they're the last admin
of an otherwise nonempty chat.
"""
type CannotLeaveChat {
    placeholder: Placeholder!
}

union SearchChatMessagesResult = MessageEdges | InvalidChatId

union ReadChatResult = PrivateChat | GroupChat | InvalidChatId

union ReadGroupChatResult = GroupChatInfo | InvalidInviteCode

union RequestTokenSetResult = TokenSet | NonexistentUser | UnverifiedEmailAddress | IncorrectPassword

union VerifyEmailAddressResult = InvalidVerificationCode | UnregisteredEmailAddress

union ResetPasswordResult = InvalidPasswordResetCode | UnregisteredEmailAddress

union UpdateAccountResult = UsernameTaken | EmailAddressTaken

union CreateAccountResult = UsernameTaken | EmailAddressTaken | InvalidDomain

union EmailEmailAddressVerificationResult = UnregisteredEmailAddress | EmailAddressVerified

union CreateGroupChatResult = CreatedChatId | InvalidAdminId

union CreatePrivateChatResult = CreatedChatId | InvalidUserId

union CreateTextMessageResult = InvalidChatId | InvalidMessageId

union CreateActionMessageResult = InvalidChatId | InvalidAction | InvalidMessageId

union CreateGroupChatInviteMessageResult = InvalidChatId | InvalidInvitedChat | InvalidMessageId

union CreatePollMessageResult = InvalidChatId | InvalidMessageId | InvalidPoll

union ForwardMessageResult = InvalidChatId | InvalidMessageId

union TriggerActionResult = InvalidMessageId | InvalidAction

union SetPollVoteResult = InvalidMessageId | NonexistentOption

union LeaveGroupChatResult = InvalidChatId | CannotLeaveChat

union ReadOnlineStatusResult = OnlineStatus | InvalidUserId
