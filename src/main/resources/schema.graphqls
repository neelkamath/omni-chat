"""Complies with ISO 8601."""
scalar DateTime

"""A cursor for pagination."""
scalar Cursor

"""
A username must be 1-30 characters long. Only lowercase English letters (a-z), English numbers (0-9), periods, and
underscores are allowed.
"""
scalar Username

"""A name must neither contain whitespace nor exceed 30 characters. An empty string corresponds to no name."""
scalar Name

"""
A user's bio which cannot exceed 2,500 characters, and uses GitHub Flavored Markdown. Leading and trailing whitespace is
disallowed. An empty string corresponds to no bio.
"""
scalar Bio

"""A password which contains non-whitespace characters."""
scalar Password

"""1-70 characters, of which at least one isn't whitespace. Leading and trailing whitespace is disallowed."""
scalar GroupChatTitle

"""
At most 1,000 characters, and uses GitHub Flavored Markdown. Leading and trailing whitespace is disallowed. An empty
string corresponds to no description.
"""
scalar GroupChatDescription

"""
1-10,000 characters, of which at least one isn't whitespace. Uses GitHub Flavored Markdown. Leading and trailing
whitespace is disallowed.
"""
scalar MessageText

scalar Uuid

"""
GraphQL mandates data be returned for every operation, and data be present in every type. However, certain operations
and types don't have relevant data. This type, which is an empty `String`, indicates such.
"""
scalar Placeholder

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

type Query {
    """
    An access token must be sent with this request if the `messageId` isn't from a public chat. Sending an access token
    for a public chat will return the message as viewed by the user (e.g., the message may be stated as being starred).
    If there's no such `messageId` visible to the user (including anonymous users), then the user will be unauthorized.
    """
    readMessage(messageId: Int!): Message!

    """
    Returns the user's starred messages.

    An access token must be sent with this request.
    """
    readStars(first: Int, after: Cursor): StarredMessagesConnection!

    """
    Returns users blocked by this user.

    An access token must be sent with this request.
    """
    readBlockedUsers(first: Int, after: Cursor): AccountsConnection!

    """
    Whether the `userId` is online. If the `userId` exists, an `OnlineStatus` will be returned. Otherwise, an
    `InvalidUserId` will be returned.
    """
    readOnlineStatus(userId: Int!): ReadOnlineStatusResult!

    """
    The users who are typing in a chat the user is in.

    An access token must be sent with this request.
    """
    readTypingUsers: [TypingUsers!]!

    """
    Case-insensitively `query`s text messages, poll message title and options, action message text and actions, and pic
    message captions in the `chatId`. The returned `MessageEdge`s are chronologically ordered.

    A returned `InvalidChatId` indicates that the chat isn't public, and the user isn't in the chat.

    An access token must be sent with this request if the `chatId` isn't a public chat. Sending an access token for a
    public chat will return the chat as viewed by the user (e.g., messages they starred will be stated as such).
    """
    searchChatMessages(chatId: Int!, query: String!, last: Int, before: Cursor): SearchChatMessagesResult!

    """
    Case-insensitively `query`s every text message, poll message's title and options, action message's text and actions,
    and pic message's caption in every chat the user is in. Each item in the returned `ChatMessages` will be for a
    particular `ChatMessages.chat`, and have the `ChatMessages.messages` from the search results. Each chat's messages
    are chronologically ordered.

    An access token must be sent with this request.
    """
    searchMessages(query: String!, first: Int, after: Cursor): ChatMessagesConnection!

    """
    Returns the user's account info.

    An access token must be sent with this request.
    """
    readAccount: Account!

    """
    Returns the chats the user is in.

    An access token must be sent with this request.
    """
    readChats(first: Int, after: Cursor): ChatsConnection!

    """
    An access token must be sent with this request if the chat being read isn't a public chat. Sending an access token
    for a public chat will return the chat as viewed by the user (e.g., messages they starred will be stated as such).
    """
    readChat(id: Int!): ReadChatResult!

    """
    Returns the `GroupChatInfo` the `inviteCode` is for. This could be used to display a chat the user isn't in but was
    invited to, so that they can check whether they'd like to join.
    """
    readGroupChat(inviteCode: Uuid!): ReadGroupChatResult!

    """
    Case-insensitively searches group chats and private chats the user is in. Private chats are searched by matching the
    `query` with the username, first name, and last name of users the user has chats with. Group chats are searched by
    matching the `query` with the title of group chats the user is in.

    An access token must be sent with this request.
    """
    searchChats(query: String!, first: Int, after: Cursor): ChatsConnection!

    """
    Searches chats by case-insensitively `query`ing their titles.

    If an access token is sent with this request, the chats will be returned as viewed by the user (e.g., messages they
    starred will be stated as such).
    """
    searchPublicChats(query: String!, first: Int, after: Cursor): GroupChatsConnection!

    """
    Retrieves saved contacts.

    An access token must be sent with this request.
    """
    readContacts(first: Int, after: Cursor): AccountsConnection!

    """
    Case-insensitively searches contacts by `query`ing their usernames, first names, last names, and email addresses.

    An access token must be sent with this request.
    """
    searchContacts(query: String!, first: Int, after: Cursor): AccountsConnection!

    """
    Operations such as `Query.updateAccount` require authentication via an access token. An access token can be acquired
    by passing the user's `Login` to this operation. Once the access token has expired, the `TokenSet.refreshToken` can
    be passed to `Query.refreshTokenSet`.
    """
    requestTokenSet(login: Login!): RequestTokenSetResult!

    """
    The access token is short-lived. Once it expires, the user would have to log in again. This can be avoided by
    passing the `TokenSet.refreshToken` from `Query.requestTokenSet` as the `refreshToken` to request a new `TokenSet`.
    """
    refreshTokenSet(refreshToken: ID!): TokenSet!

    """
    Searches users. The `query` is case-insensitively matched against users' usernames, email addresses, first names,
    and last names. Returns the users found.
    """
    searchUsers(query: String!, first: Int, after: Cursor): AccountsConnection!

    """
    Searches blocked users. The `query` is case-insensitively matched against users' usernames, email addresses, first
    names, and last names. Returns the users found.

    An access token must be sent with this request.
    """
    searchBlockedUsers(query: String!, first: Int, after: Cursor): AccountsConnection!
}

type Mutation {
    """
    Blocks the specified user. Does nothing if the user has already been blocked, or the user is blocking themselves.
    `null` will be returned if the operation succeeded. An `InvalidUserId` will be returned if the specified user
    doesn't exist.

    An access token must be sent with this request.
    """
    blockUser(id: Int!): InvalidUserId

    """
    Unblocks the specified user. Returns `true` if the user got unblocked. Returns `false` if either the user wasn't
    blocked or the `id` doesn't exist.

    An access token must be sent with this request.
    """
    unblockUser(id: Int!): Boolean!

    """
    Deletes the user's account. All the user's data will be wiped from the system. This means that users in private
    chats with the user will have their chats deleted, etc. `null` will be returned if the account was deleted.

    An access token must be sent with this request.
    """
    deleteAccount: CannotDeleteAccount

    """
    When a user creates an account, or updates their email address, they'll receive an email with a `verificationCode`
    which must be passed to this operation in order to verify their email address. If the `verificationCode` is valid,
    the account's email address verification status will be set to verified, and `null` will be returned. Use
    `Mutation.emailEmailAddressVerification` if the user lost their verification code.
    """
    verifyEmailAddress(emailAddress: String!, verificationCode: Int!): VerifyEmailAddressResult

    """
    Updates the password of the account associated with the `emailAddress` to the `newPassword` if the
    `passwordResetCode` is correct, and returns `null`.
    """
    resetPassword(emailAddress: String!, passwordResetCode: Int!, newPassword: Password!): ResetPasswordResult

    """
    Stars the `messageId`. The user can star their own messages. Starring an already starred message will do nothing.
    `null` will be returned if the operation succeeded. An `InvalidMessageId` will be returned if the message doesn't
    exist.

    An access token must be sent with this request.
    """
    star(messageId: Int!): InvalidMessageId

    """
    Unstars the `messageId`. Does nothing if either the message doesn't exist or the message wasn't starred.

    An access token must be sent with this request.
    """
    unstar(messageId: Int!): Placeholder!

    """
    Sets the current user's status to `isOnline`.

    An access token must be sent with this request.
    """
    setOnline(isOnline: Boolean!): Placeholder!

    """
    Sets whether the user `isTyping` in the `chatId`. `null` will be returned if the operation succeeded. An
    `InvalidChatId` will be returned if the user isn't in the chat.

    Let's consider an example use case. Once the user starts typing, the other users in the chat will see a typing
    status on the user. Once the user stops typing for more than two seconds, the typing status will be removed.

    An access token must be sent with this request.
    """
    setTyping(chatId: Int!, isTyping: Boolean!): InvalidChatId

    """
    Deletes the user's profile pic.

    An access token must be sent with this request.
    """
    deleteProfilePic: Placeholder!

    """
    Deletes the group chat's profile pic. The user must be the admin.

    An access token must be sent with this request.
    """
    deleteGroupChatPic(chatId: Int!): Placeholder!

    """
    Records that the user received or read the `messageId`. If the `status` is `MessageStatus.READ`, and there's no
    `MessageStatus.DELIVERED` record, the delivery status will be created. Nothing will happen if the status was already
    created.

    `null` will be returned if the operation succeeded. An `InvalidMessageId` will be returned if either the message
    doesn't exist in a chat the user is in or the message is the user's own.

    An access token must be sent with this request.
    """
    createStatus(messageId: Int!, status: MessageStatus!): InvalidMessageId

    """
    Updates the user's account. Only the non-null fields will be updated. None of the updates will take place if even
    one of the fields were invalid. If the user updates their email address to something other than their current
    address, they must be loged out because the current access token will be invalid until they verify their new email
    address. `null` will be returned if the operation succeeded.

    If the user updates their email address, they'll be required to verify it before their next login via an email which
    is sent to it. This means they'll be locked out of their account if they provide an invalid address, and will have
    to contact the service's admin to correctly update their address. This mistake can be prevented by asking them to
    confirm their address. For example, a UI could require the user to enter their email address twice if they're
    updating it, and only allow the update to take place if both the entered addresses match.

    An access token must be sent with this request.
    """
    updateAccount(update: AccountUpdate!): UpdateAccountResult

    """
    Creates an account, and sends the user a verification email. The user will not be allowed to log in until they
    verify their email address. Use `Mutation.verifyEmailAddress` to verify the user's email address. `null` will be
    returned if the operation succeeded.
    """
    createAccount(account: AccountInput!): CreateAccountResult

    """
    Sends the user an email to verify their `emailAddress`. An example use case for this operation is when the user
    created an account (which caused an email address verification email to be sent) but accidentally deleted the email,
    and therefore requires it to be resent. `null` will be returned if the operation succeeded.
    """
    emailEmailAddressVerification(emailAddress: String!): EmailEmailAddressVerificationResult

    """
    Sends a password reset email to the supplied `emailAddress`. The email will contain a password reset code which must
    then be passed to `Mutation.resetPassword`. If the user is logged in (i.e., an access token is present), and wants
    to update their password, `Mutation.updateAccount` should be used instead. `null` will be returned if the operation
    succeeded.
    """
    emailPasswordResetCode(emailAddress: String!): UnregisteredEmailAddress

    """An access token must be sent with this request. Only an admin can perform this operation."""
    updateGroupChatTitle(chatId: Int!, title: GroupChatTitle!): Placeholder!

    """An access token must be sent with this request. Only an admin can perform this operation."""
    updateGroupChatDescription(chatId: Int!, description: GroupChatDescription!): Placeholder!

    """
    Nonexisting users, and users who are already in the chat will be ignored.

    An access token must be sent with this request. Only an admin can perform this operation.
    """
    addGroupChatUsers(chatId: Int!, userIdList: [Int!]!): Placeholder!

    """
    Removes the specified users from the `chatId` which may include admins including the user themself. Messages sent
    by, and polls voted on, by removed users will remain. Nonexisting users, and users who aren't in the chat will be
    ignored. Every message a removed user had starred in the specified chat will be unstarred for them. `null` will be
    returned if the operation succeeded.

    An access token must be sent with this request. Only an admin can perform this operation.
    """
    removeGroupChatUsers(chatId: Int!, userIdList: [Int!]!): CannotLeaveChat

    """
    Leaves the chat the user is in. Messages sent by, and polls voted on, by removed users will remain. Every message
    the user has starred in the specified chat will be unstarred for them.

    Returns `null` if the operation succeeded. An `InvalidChatId` will be returned if the user isn't the specified group
    chat.

    An access token must be sent with this request.
    """
    leaveGroupChat(chatId: Int!): LeaveGroupChatResult

    """
    Makes every user in the `idList` an admin of the `chatId`. Nonexisting users, users who aren't in the chat, and
    users who are already admins, are ignored.

    An access token must be sent with this request. Only an admin can perform this operation.
    """
    makeGroupChatAdmins(chatId: Int!, userIdList: [Int!]!): Placeholder!

    """
    Creates a group chat. Nonexisting users are ignored. The `chat` parameter's `GroupChatInput.userIdList` and
    `GroupChatInput.adminIdList` needn't contain the user's own ID, as it is implicitly included.

    If an `InvalidAdminId` is returned, it indicates that the `chat` parameter's `GroupChatInput.adminIdList` wasn't a
    subset of the `GroupChatInput.userIdList`.

    An access token must be sent with this request.
    """
    createGroupChat(chat: GroupChatInput!): CreateGroupChatResult!

    """
    Sets whether the `chatId` `isBroadcast`. The user must be an admin to perform this operation.

    An access token must be sent with this request.
    """
    setBroadcast(chatId: Int!, isBroadcast: Boolean!): Placeholder!

    """
    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if either the chat isn't a
    group chat or the chat is a public chat.

    An access token must be sent with this request. The user must be an admin to perform this operation.
    """
    setInvitability(chatId: Int!, isInvitable: Boolean!): InvalidChatId

    """
    Joins the chat the `inviteCode` is for.

    Nothing will happen if the user is already in the chat. `null` will be returned if the operation succeeded. An
    `InvalidInviteCode` will be returned if there's no invitable chat having the `inviteCode` (e.g., the `inviteCode` is
    now invalid because the admin of its group chat switched off invites). You can easily join a public chat using
    `Mutation.joinPublicChat`.

    An access token must be sent with this request.
    """
    joinGroupChat(inviteCode: Uuid!): InvalidInviteCode

    """
    Joins the specified public chat. Nothing will happen if the user is already in the chat. `null` will be returned if
    the operation succeeded. An `InvalidChatId` will be returned if there's no such public chat.

    An access token must be sent with this request.
    """
    joinPublicChat(chatId: Int!): InvalidChatId

    """
    Deletes a private chat. Any messages the user starred in the chat will be unstarred.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the user isn't in the
    chat.

    An access token must be sent with this request.
    """
    deletePrivateChat(chatId: Int!): InvalidChatId

    """
    Creates a private chat with the `userId` unless the chat already exists. In either case, the chat's ID will be
    returned. A returned `InvalidUserId` indicates that the specified user doesn't exist.

    An access token must be sent with this request.
    """
    createPrivateChat(userId: Int!): CreatePrivateChatResult!

    """
    Sends the `text` in the `chatId`. If the `chatId` is a broadcast chat, the user must be an admin to message. The
    user might want to give their message a context, such as when replying to a message sent several messages ago. In
    this case, the `contextMessageId` is to be the ID of the message being replied to.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the user isn't in the
    chat. An `InvalidMessageId` will be returned if the `contextMessageId` doesn't exist.

    An access token must be sent with this request.
    """
    createTextMessage(chatId: Int!, text: MessageText!, contextMessageId: Int): CreateTextMessageResult

    """
    Sends the `text` in the `chatId`. For example, a restaurant's bot asks if the user wants a burger or a pizza in the
    `text`, and the `actions` are `"burger"` and `"pizza"`. If the `chatId` is a broadcast chat, the user must be an
    admin to message. The user might want to give their message a context, such as when replying to a message sent
    several messages ago. In this case, the `contextMessageId` is to be the ID of the message being replied to.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the user isn't in the
    chat. An `InvalidAction` will be returned if either there were zero `actions` or the `actions` weren't unique. An
    `InvalidMessageId` will be returned if the `contextMessageId` doesn't exist.

    A frontend UI could display this message like a regular text message but with buttons below it. Action messages are
    meant for bots; human users shouldn't be able to create them. Only the creator of the action message will be
    notified when `Mutation.triggerAction` gets called.

    An access token must be sent with this request.
    """
    createActionMessage(chatId: Int!, message: ActionMessageInput!, contextMessageId: Int): CreateActionMessageResult

    """
    Creates a `GroupChatInviteMessage` in the `chatId` inviting users to join the `invitedChatId`. If the `chatId` is a
    broadcast chat, the user must be an admin to message. The user might want to give their message a context, such as
    when replying to a message sent several messages ago. In this case, the `contextMessageId` is to be the ID of the
    message being replied to.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if either the user isn't in
    the `chatId` or the `chatId` is the same as the `invitedChatId`. An `InvalidInvitedChat` will be returned if the
    `invitedChatId` isn't a group chat, the chat has turned off invitations, or the user isn't in it. An
    `InvalidMessageId` will be returned if the `contextMessageId` doesn't exist.

    Users aren't allowed to create invite messages for chats they aren't in because there's no use case for it, and
    hackers could brute force joining many invitable chats in this manner. Users can, however, forward group chat
    invite messages even if they aren't in the chat they're being invited to. An example use case of this is a college
    student forwarding an invite for the Chemistry group chat to their friends even though they themselves haven't
    joined the Chemistry chat because they didn't take up that subject.

    A frontend UI might want to hide the `GroupChatInviteMessage.inviteCode`, and instead display the `GroupChatInfo`
    returned by `Query.readGroupChat`. The user needn't be in the `invitedChatId` because it's possible that they were
    simply required to forward a group chat invite to the relevant people.

    An access token must be sent with this request.
    """
    createGroupChatInviteMessage(
        chatId: Int!
        invitedChatId: Int!
        contextMessageId: Int
    ): CreateGroupChatInviteMessageResult

    """
    Sends the `poll` in the `chatId`. If the `chatId` is a broadcast chat, the user must be an admin to message. The
    user might want to give their message a context, such as when replying to a message sent several messages ago. In
    this case, the `contextMessageId` is to be the ID of the message being replied to.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the user isn't in the
    chat. An `InvalidMessageId` will be returned if the `contextMessageId` doesn't exist.

    An access token must be sent with this request.
    """
    createPollMessage(chatId: Int!, poll: PollInput!, contextMessageId: Int): CreatePollMessageResult

    """
    Forwards the `messageId` to the `chatId`. If the `chatId` is a broadcast chat, the user must be an admin to message.
    The user might want to give their message a context, such as when replying to a message sent several messages ago.
    In this case, the `contextMessageId` is to be the ID of the message being replied to.

    `null` will be returned if the operation succeeded. An `InvalidChatId` will be returned if the user isn't in the
    `chatId`, the `messageId` is from the `chatId` (messages can't be forwarded in their own chats), or the `messageId`
    is a group chat invite for the `chatId`. An `InvalidMessageId` will be returned if the `messageId` or
    `contextMessageId` doesn't exist.

    An access token must be sent with this request.
    """
    forwardMessage(chatId: Int!, messageId: Int!, contextMessageId: Int): ForwardMessageResult

    """
    Triggers the `action` on the `messageId`'s action message. Returns whether the operation was successful.

    `false` will be returned if there's no such action message, the user can't see the message (e.g., the message is
    from a private chat which they had deleted), the user isn't in the chat, or the `action` doesn't exist on the
    `messageId`.

    An access token must be sent with this request.
    """
    triggerAction(messageId: Int!, action: MessageText!): Boolean!

    """
    Updates the user's vote for the `option` on the `messageId`'s poll. If `vote` is `true`, the user's vote will be
    added if it hasn't already. If `vote` is `false`, the user's vote will be removed if there is one.

    `null` will be returned if the operation succeeded. An `InvalidMessageId` will be returned if there's no such poll
    message.

    An access token must be sent with this request.
    """
    setPollVote(messageId: Int!, option: MessageText!, vote: Boolean!): SetPollVoteResult

    """
    Deletes the message `id` from the chat it's from. The user can only delete their own messages.

    `null` will be returned if the operation succeeded. An `InvalidMessageId` will be returned if the message isn't in a
    chat the user is in, the message isn't visible to the user because they deleted the private chat, or the message
    isn't the user's own.

    An access token must be sent with this request.
    """
    deleteMessage(id: Int!): InvalidMessageId

    """
    Deletes the specified user from the user's contacts. Returns `true` if the contact got deleted. Returns `false` if
    the `id` was either not a contact or a nonexisting user ID.

    An access token must be sent with this request.
    """
    deleteContact(id: Int!): Boolean!

    """
    Saves the specified user as a contact. Returns `true` if the contact got saved. Returns `false` if the `id` was
    either a preexisting contact or a nonexisting user ID.

    An access token must be sent with this request.
    """
    createContact(id: Int!): Boolean!
}

type Subscription {
    """
    Yields created, updated, and deleted messages (including the user's own messages) in every chat the user is in. A
    message from a chat the user wasn't previously in can be sent as well (e.g., when the other user in a private chat
    the user deleted sends a message in it). The subscription will be stopped if the user deletes their account.

    An access token must be sent with this request. See `Subscription.subscribeToChatMessages` for unauthenticated
    users such as an accountless user viewing a public chat.
    """
    subscribeToMessages: MessagesSubscription!

    """
    Yields created, updated, and deleted messages for the `chatId`. If the user is authenticated, you probably want to
    use `Subscription.subscribeToMessages` instead.

    The subscription will be stopped if the chat gets deleted. If the `chatId` isn't an existing public chat, then an
    `InvalidChatId` will be returned, and the subscription will be closed.
    """
    subscribeToChatMessages(chatId: Int!): ChatMessagesSubscription!

    """
    Yields the online statuses of users the user has in their contacts, or has a chat with. The subscription will be
    stopped if the user deletes their account.

    An access token must be sent with this request. See `Subscription.subscribeToChatOnlineStatuses` for unauthenticated
    users such as an accountless user viewing a public chat.
    """
    subscribeToOnlineStatuses: OnlineStatusesSubscription!

    """
    Yields the online statuses of users in the `chatId`. If the user is authenticated, you probably want to use
    `Subscription.subscribeToOnlineStatuses` instead.

    The subscription will be stopped if the chat gets deleted. If the `chatId` isn't an existing public chat, then an
    `InvalidChatId` will be returned, and the subscription will be closed.
    """
    subscribeToChatOnlineStatuses(chatId: Int!): ChatOnlineStatusesSubscription!

    """
    Yields typing statuses for chats the user has. The subscription will be stopped if the user deletes their account.

    An access token must be sent with this request. See `Subscription.subscribeToChatTypingStatuses` for unauthenticated
    users such as an accountless user viewing a public chat.
    """
    subscribeToTypingStatuses: TypingStatusesSubscription!

    """
    Yields typing statuses for the `chatId`.

    The subscription will be stopped if the chat gets deleted. If the `chatId` isn't an existing public chat, then an
    `InvalidChatId` will be returned, and the subscription will be closed.
    """
    subscribeToChatTypingStatuses(chatId: Int!): ChatTypingStatusesSubscription!

    """
    Yields updates on the user's contacts, the subscriber's account, and accounts of users the subscriber has a chat
    with. The subscription will be stopped if the user deletes their account.

    An access token must be sent with this request. See `Subscription.subscribeToChatAccounts` for unauthenticated users
    such as an accountless user viewing a public chat.
    """
    subscribeToAccounts: AccountsSubscription!

    """
    Yields updates on the accounts of users in the `chatId`.

    The subscription will be stopped if the chat gets deleted. If the `chatId` isn't an existing public chat, then an
    `InvalidChatId` will be returned, and the subscription will be closed.
    """
    subscribeToChatAccounts(chatId: Int!): ChatAccountsSubscription!

    """
    Yields group chats the user was added to (including chats they created), group chat metadata updates, and private
    chat deletions. The subscription will be stopped if the user deletes their account.

    An access token must be sent with this request. See `Subscription.subscribeToGroupChatMetadata` for unauthenticated
    users such as an accountless user viewing a public chat.
    """
    subscribeToChats: ChatsSubscription!

    """
    Yields metadata updates for the `chatId`.

    The subscription will be stopped if the chat gets deleted. If the `chatId` isn't an existing public chat, then an
    `InvalidChatId` will be returned, and the subscription will be closed.
    """
    subscribeToGroupChatMetadata(chatId: Int!): GroupChatMetadataSubscription!
}

union MessagesSubscription =
    | CreatedSubscription
    | NewTextMessage
    | NewActionMessage
    | NewPicMessage
    | NewAudioMessage
    | NewGroupChatInviteMessage
    | NewDocMessage
    | NewVideoMessage
    | NewPollMessage
    | UpdatedMessage
    | UpdatedPollMessage
    | TriggeredAction
    | DeletedMessage
    | UserChatMessagesRemoval
    | UnstarredChat

union ChatMessagesSubscription =
    | CreatedSubscription
    | NewTextMessage
    | NewActionMessage
    | NewPicMessage
    | NewAudioMessage
    | NewGroupChatInviteMessage
    | NewDocMessage
    | NewVideoMessage
    | NewPollMessage
    | UpdatedMessage
    | UpdatedPollMessage
    | DeletedMessage
    | UserChatMessagesRemoval
    | InvalidChatId

"""Every message in the chat has been unstarred by the user."""
type UnstarredChat {
    chatId: Int!
}

union OnlineStatusesSubscription = CreatedSubscription | OnlineStatus

union ChatOnlineStatusesSubscription = CreatedSubscription | OnlineStatus | InvalidChatId

union TypingStatusesSubscription = CreatedSubscription | TypingStatus

union ChatTypingStatusesSubscription = CreatedSubscription | TypingStatus | InvalidChatId

"""
A user will be automatically unblocked when they delete their account. In this scenario, an `UnblockedAccount` will not
be sent because it's a rare event, and the client would've had to deal with the user viewing a user who's account was
just deleted.
"""
union AccountsSubscription =
    | CreatedSubscription
    | NewContact
    | UpdatedAccount
    | UpdatedProfilePic
    | DeletedContact
    | BlockedAccount
    | UnblockedAccount
    | DeletedAccount

union ChatAccountsSubscription =
    | CreatedSubscription
    | UpdatedAccount
    | UpdatedProfilePic
    | DeletedAccount
    | InvalidChatId

"""The `userId` who deleted their account."""
type DeletedAccount {
    userId: Int!
}

"""The `userId` of the user who updated their profile pic."""
type UpdatedProfilePic {
    userId: Int!
}

"""
A `GroupChatId` is the ID of the chat the user was added to.

If the subscriber leaves the chat, they will receive their own `ExitedUsers` message.
"""
union ChatsSubscription =
    | CreatedSubscription
    | GroupChatId
    | UpdatedGroupChatPic
    | UpdatedGroupChat
    | ExitedUsers
    | DeletedPrivateChat

union GroupChatMetadataSubscription =
    | CreatedSubscription
    | UpdatedGroupChatPic
    | UpdatedGroupChat
    | ExitedUsers
    | InvalidChatId

"""The `chatId` of the group chat whose pic was updated."""
type UpdatedGroupChatPic {
    chatId: Int!
}

"""
The `action` on the action `messageId` which was `triggeredBy` the user. This will only be sent to the user who created
the action message.
"""
type TriggeredAction {
    messageId: Int!
    action: MessageText!
    triggeredBy: Account!
}

type OnlineStatus {
    userId: Int!
    isOnline: Boolean!
    """`null` if the `userId` has never set an online status."""
    lastOnline: DateTime
}

"""Whether the `userId` `isTyping` in the `chatId`."""
type TypingStatus {
    chatId: Int!
    userId: Int!
    isTyping: Boolean!
}

"""The `users` who are typing in the `chatId`."""
type TypingUsers {
    chatId: Int!
    users: [Account!]!
}

type GroupChatId {
    chatId: Int!
}

"""The users who left the group chat."""
type ExitedUsers {
    chatId: Int!
    userIdList: [Int!]!
}

"""This will not be sent if the profile pic was updated."""
type UpdatedAccount implements AccountData {
    userId: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""
Null fields haven't been updated. If a non-null field hasn't been updated, its value will be the same as before. This
will not be sent if the pic has been updated.
"""
type UpdatedGroupChat {
    chatId: Int!
    title: GroupChatTitle
    description: GroupChatDescription
    newUsers: [Account!]
    removedUsers: [Account!]
    adminIdList: [Int!]
    isBroadcast: Boolean
    publicity: GroupChatPublicity
}

"""
Every message the `userId` sent in the `chatId` has been deleted. This happens when a group chat's member deletes their
account.
"""
type UserChatMessagesRemoval {
    chatId: Int!
    userId: Int!
}

"""
Indicates that the `Subscription` has been created. This will only be sent only once, and will be the first event sent.
"""
type CreatedSubscription {
    placeholder: Placeholder!
}

"""The `messageId` has been deleted from the `chatId`."""
type DeletedMessage {
    chatId: Int!
    messageId: Int!
}

input PollInput {
    """For example, `"Where should we meet?"`."""
    title: MessageText!
    """There must be at least two options. Each option must be unique. For example, `["Burger King", "Pizza Hut"]`."""
    options: [MessageText!]!
}

type PollOption {
    option: MessageText!
    """The ID of every user who voted for the `option`."""
    votes: [Account!]!
}

"""A user can vote for each option at most once, but can vote for multiple options."""
type Poll {
    title: MessageText!
    """There are at least two options, each of which are unique."""
    options: [PollOption!]!
}

input ActionMessageInput {
    """For example, `"What would you like to order?"`."""
    text: MessageText!
    """There must be at least one action. Each action must be unique. For example, `["Pizza", "Burger"]`."""
    actions: [MessageText!]!
}

type ActionableMessage {
    text: MessageText!
    """There's at least one action. Each action is unique."""
    actions: [MessageText!]!
}

type GroupChatsConnection {
    edges: [GroupChatEdge!]!
    pageInfo: PageInfo!
}

type GroupChatEdge {
    node: GroupChat!
    cursor: Cursor!
}

type ChatsConnection {
    edges: [ChatEdge!]!
    pageInfo: PageInfo!
}

type ChatEdge {
    node: Chat!
    cursor: Cursor!
}

type AccountsConnection {
    edges: [AccountEdge!]!
    pageInfo: PageInfo!
}

type AccountEdge {
    node: Account!
    cursor: Cursor!
}

"""The user deleted the `chatId`."""
type DeletedPrivateChat {
    chatId: Int!
}

interface AccountData {
    userId: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

type Account implements AccountData {
    userId: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""A blocked user."""
type BlockedAccount implements AccountData {
    userId: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""The `userId` of an unblocked user."""
type UnblockedAccount {
    userId: Int!
}

type NewContact implements AccountData {
    userId: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""
The `id` of the contact which has been deleted for the user. This happens when the user deletes a contact, or the
contact's account gets deleted.
"""
type DeletedContact {
    userId: Int!
}

input AccountInput {
    username: Username!
    password: Password!
    emailAddress: String!
    firstName: Name! = ""
    lastName: Name! = ""
    bio: Bio! = ""
}

type ChatMessagesConnection {
    edges: [ChatMessagesEdge!]!
    pageInfo: PageInfo!
}

type ChatMessagesEdge {
    node: ChatMessages!
    cursor: Cursor!
}

type ChatMessages {
    chat: Chat!
    # Use backward (instead of forward) pagination because users would want to prioritize searching recent messages.
    messages(last: Int, before: Cursor): [MessageEdge!]!
}

interface Chat {
    chatId: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
}

type MessagesConnection {
    edges: [MessageEdge!]!
    pageInfo: PageInfo!
}

type StarredMessagesConnection {
    edges: [StarredMessageEdge!]!
    pageInfo: PageInfo!
}

type StarredMessageEdge {
    node: StarredMessage!
    cursor: Cursor!
}

type MessageEdge {
    node: Message!
    cursor: Cursor!
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: Cursor
    endCursor: Cursor
}

interface BareGroupChat {
    title: GroupChatTitle!
    description: GroupChatDescription!
    """The ID of the `users` who are the admins. There will be at least one admin."""
    adminIdList: [Int!]!
    users(first: Int, after: Cursor): AccountsConnection!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
}

type GroupChatInfo implements BareGroupChat {
    title: GroupChatTitle!
    description: GroupChatDescription!
    adminIdList: [Int!]!
    users(first: Int, after: Cursor): AccountsConnection!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
}

type GroupChat implements Chat, BareGroupChat {
    chatId: Int!
    title: GroupChatTitle!
    description: GroupChatDescription!
    adminIdList: [Int!]!
    users(first: Int, after: Cursor): AccountsConnection!
    messages(last: Int, before: Cursor): MessagesConnection!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
    """null if invite codes are turned off."""
    inviteCode: Uuid
}

type PrivateChat implements Chat {
    chatId: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
    """The user being chatted with."""
    user: Account!
}

type MessageContext {
    """Whether this message was in reply to a particular message."""
    hasContext: Boolean!
    """
    The ID of the context message.

    If this message doesn't `hasContext`, this will be null. If this message `hasContext`, this will be null only if the
    context message was deleted. Since this message might not make any sense without the context, if this message
    `hasContext`, but the context message was deleted, a frontend UI could replace what should've been the context
    message with something similar to "Message deleted".
    """
    messageId: Int
}

type MessageDateTimeStatusConnection {
    edges: [MessageDateTimeStatusEdge!]!
    pageInfo: PageInfo!
}

type MessageDateTimeStatusEdge {
    node: MessageDateTimeStatus!
    cursor: Cursor!
}

interface Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    """`false` if either the user hasn't starred this message or the message is being read anonymously."""
    hasStar: Boolean!
}

type TextMessage implements Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    """`false` if either the user hasn't starred this message or the message is being read anonymously."""
    hasStar: Boolean!
    textMessage: MessageText!
}

type ActionMessage implements Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    """`false` if either the user hasn't starred this message or the message is being read anonymously."""
    hasStar: Boolean!
    actionableMessage: ActionableMessage!
}

type PicMessage implements Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    """`false` if either the user hasn't starred this message or the message is being read anonymously."""
    hasStar: Boolean!
    caption: MessageText
}

type PollMessage implements Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    """`false` if either the user hasn't starred this message or the message is being read anonymously."""
    hasStar: Boolean!
    poll: Poll!
}

type AudioMessage implements Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    """`false` if either the user hasn't starred this message or the message is being read anonymously."""
    hasStar: Boolean!
}

type GroupChatInviteMessage implements Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    """`false` if either the user hasn't starred this message or the message is being read anonymously."""
    hasStar: Boolean!
    """`null` if either the chat no longer exists or the chat currently has invitations switched off."""
    inviteCode: Uuid
}

type DocMessage implements Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    """`false` if either the user hasn't starred this message or the message is being read anonymously."""
    hasStar: Boolean!
}

type VideoMessage implements Message {
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    """`false` if either the user hasn't starred this message or the message is being read anonymously."""
    hasStar: Boolean!
}

"""A message which is starred by the user."""
interface StarredMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
}

type StarredTextMessage implements StarredMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    textMessage: MessageText!
}

type StarredActionMessage implements StarredMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    actionableMessage: ActionableMessage!
}

type StarredPicMessage implements StarredMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    caption: MessageText
}

type StarredPollMessage implements StarredMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    poll: Poll!
}

type StarredAudioMessage implements StarredMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
}

type StarredGroupChatInviteMessage implements StarredMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
    """`null` if either the chat no longer exists or the chat currently has invitations switched off."""
    inviteCode: Uuid
}

type StarredDocMessage implements StarredMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
}

type StarredVideoMessage implements StarredMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    context: MessageContext!
    isForwarded: Boolean!
}

interface NewMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    context: MessageContext!
    isForwarded: Boolean!
}

type NewTextMessage implements NewMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    context: MessageContext!
    isForwarded: Boolean!
    textMessage: MessageText!
}

type NewActionMessage implements NewMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    context: MessageContext!
    isForwarded: Boolean!
    actionableMessage: ActionableMessage!
}

type NewPicMessage implements NewMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    context: MessageContext!
    isForwarded: Boolean!
    caption: MessageText
}

type NewPollMessage implements NewMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    context: MessageContext!
    isForwarded: Boolean!
    poll: Poll!
}

type NewAudioMessage implements NewMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    context: MessageContext!
    isForwarded: Boolean!
}

type NewGroupChatInviteMessage implements NewMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    context: MessageContext!
    isForwarded: Boolean!
    """`null` if either the chat no longer exists or the chat currently has invitations switched off."""
    inviteCode: Uuid
}

type NewDocMessage implements NewMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    context: MessageContext!
    isForwarded: Boolean!
}

type NewVideoMessage implements NewMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    state: MessageState!
    sent: DateTime!
    context: MessageContext!
    isForwarded: Boolean!
}

"""An existing `messageId` in the `chatId` which has been starred, unstarred, delivered to a user, or read by a user."""
type UpdatedMessage {
    chatId: Int!
    messageId: Int!
    state: MessageState!
    statuses(first: Int, after: Cursor): MessageDateTimeStatusConnection!
    """`false` if either the user hasn't starred this message or the message is being read anonymously."""
    hasStar: Boolean!
}

"""The `dateTime` the `user` created the `status`."""
type MessageDateTimeStatus {
    user: Account!
    dateTime: DateTime!
    status: MessageStatus!
}

enum MessageState {
    """Each user in the chat hasn't had the message delivered to them yet."""
    SENT
    """Each user in the chat has had the message delivered to them but not everyone has read it yet."""
    DELIVERED
    """Each user in the chat has read the message."""
    READ
}

enum MessageStatus {
    DELIVERED, READ
}

enum GroupChatPublicity {
    """Users cannot join the chat via an invite code."""
    NOT_INVITABLE
    """Users can join the chat via an invite code."""
    INVITABLE
    """
    People can search for, and view public chats without an account. Invite codes are permanently turned on. Anyone
    with an account can join a public chat. A frontend UI may allow for a search engine to index the chat should the
    administrator allow for it. A chat must be made public when it's being created because chats can't switch between
    being public after they've been created.
    """
    PUBLIC
}

type TokenSet {
    accessToken: ID!
    refreshToken: ID!
}

input Login {
    username: Username!
    password: Password!
}

"""Only non-null fields will be updated."""
input AccountUpdate {
    username: Username
    password: Password
    emailAddress: String
    firstName: Name
    lastName: Name
    bio: Bio
}

input GroupChatInput {
    title: GroupChatTitle!
    description: GroupChatDescription!
    userIdList: [Int!]!
    adminIdList: [Int!]!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
}

"""The username doesn't exist."""
type NonexistingUser {
    placeholder: Placeholder!
}

type UnverifiedEmailAddress {
    placeholder: Placeholder!
}

"""The email address is already verified."""
type EmailAddressVerified {
    placeholder: Placeholder!
}

type UsernameTaken {
    placeholder: Placeholder!
}

type IncorrectPassword {
    placeholder: Placeholder!
}

type EmailAddressTaken {
    placeholder: Placeholder!
}

type InvalidChatId {
    placeholder: Placeholder!
}

type InvalidAdminId {
    placeholder: Placeholder!
}

type UnregisteredEmailAddress {
    placeholder: Placeholder!
}

type InvalidUserId {
    placeholder: Placeholder!
}

type InvalidMessageId {
    placeholder: Placeholder!
}

"""
The only reason the account cannot be deleted is if the user is the only admin of a group chat containing users other
than themselves. In this case, they must first appoint a different user as an admin.
"""
type CannotDeleteAccount {
    placeholder: Placeholder!
}

"""There were fewer than two options, or an option was duplicated."""
type InvalidPoll {
    placeholder: Placeholder!
}

"""The option isn't in the poll."""
type NonexistingOption {
    placeholder: Placeholder!
}

type InvalidInviteCode {
    placeholder: Placeholder!
}

"""Either the invited isn't a group chat or the chat has turned off invitations."""
type InvalidInvitedChat {
    placeholder: Placeholder!
}

"""
This Omni Chat instance disallows the provided email address's domain. For example, `"john.doe@private.company.com"` may
be allowed, but not `"john.doe@gmail.com"`.
"""
type InvalidDomain {
    placeholder: Placeholder!
}

type InvalidAction {
    placeholder: Placeholder!
}

type MessageEdges {
    edges: [MessageEdge!]!
}

type InvalidVerificationCode {
    placeholder: Placeholder!
}

type InvalidPasswordResetCode {
    placeholder: Placeholder!
}

type CreatedChatId {
    chatId: Int!
}

"""
An admin was attempted to be removed from the chat but another user must first be appointed as an admin because they're
the last admin of an otherwise nonempty chat.
"""
type CannotLeaveChat {
    placeholder: Placeholder!
}

"""The `userId` in the `chatId` updated their `vote` on the `messageId`'s `option`."""
type UpdatedPollMessage {
    chatId: Int!
    messageId: Int!
    userId: Int!
    option: MessageText!
    vote: Boolean!
}

union SearchChatMessagesResult = MessageEdges | InvalidChatId

union ReadChatResult = PrivateChat | GroupChat | InvalidChatId

union ReadGroupChatResult = GroupChatInfo | InvalidInviteCode

union RequestTokenSetResult = TokenSet | NonexistingUser | UnverifiedEmailAddress | IncorrectPassword

union VerifyEmailAddressResult = InvalidVerificationCode | UnregisteredEmailAddress

union ResetPasswordResult = InvalidPasswordResetCode | UnregisteredEmailAddress

union UpdateAccountResult = UsernameTaken | EmailAddressTaken

union CreateAccountResult = UsernameTaken | EmailAddressTaken | InvalidDomain

union EmailEmailAddressVerificationResult = UnregisteredEmailAddress | EmailAddressVerified

union CreateGroupChatResult = CreatedChatId | InvalidAdminId

union CreatePrivateChatResult = CreatedChatId | InvalidUserId

union CreateTextMessageResult = InvalidChatId | InvalidMessageId

union CreateActionMessageResult = InvalidChatId | InvalidAction | InvalidMessageId

union CreateGroupChatInviteMessageResult = InvalidChatId | InvalidInvitedChat | InvalidMessageId

union CreatePollMessageResult = InvalidChatId | InvalidMessageId | InvalidPoll

union ForwardMessageResult = InvalidChatId | InvalidMessageId

union SetPollVoteResult = InvalidMessageId | NonexistingOption

union LeaveGroupChatResult = InvalidChatId | CannotLeaveChat

union ReadOnlineStatusResult = OnlineStatus | InvalidUserId
