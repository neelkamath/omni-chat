"""Complies with ISO 8601."""
scalar DateTime

"""A cursor for pagination."""
scalar Cursor

"""A username must not contain whitespace, must be lowercase, and must be 1-30 characters long."""
scalar Username

"""A name must neither contain whitespace nor exceed 30 characters."""
scalar Name

"""A user's bio which cannot exceed 2,500 characters, and uses CommonMark."""
scalar Bio

"""A password which contains non-whitespace characters."""
scalar Password

"""1-70 characters, of which at least one isn't whitespace."""
scalar GroupChatTitle

"""At most 1,000 characters, and uses CommonMark. An empty string corresponds to no description."""
scalar GroupChatDescription

"""1-10,000 characters, of which at least one isn't whitespace. Uses CommonMark."""
scalar MessageText

scalar Uuid

"""
GraphQL mandates data be returned for every operation, and data be present in every type. However, certain operations
and types don't have relevant data. This type, which is an empty `String`, indicates such.
"""
scalar Placeholder

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

type Query {
    """
    Returns the user's starred messages.

    An access token must be sent with this request.
    """
    readStars: [StarredMessage!]!

    """
    Returns users blocked by this user.

    An access token must be sent with this request.
    """
    readBlockedUsers(first: Int, after: Cursor): AccountsConnection!

    """
    The online statuses of users the user has in their contacts, or has a chat with.

    An access token must be sent with this request.
    """
    readOnlineStatuses: [OnlineStatus!]!

    """
    The statuses of users who are typing in a chat the user is in. The user's own status won't be returned.

    An access token must be sent with this request.
    """
    readTypingStatuses: [TypingStatus!]!

    """
    Case-insensitively `query`s text messages, poll message title and options, action message text and actions, and pic
    message captions in the `chatId`.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the chat isn't public, and the user isn't in the
    chat).

    An access token must be sent with this request if the `chatId` isn't a public chat.
    """
    searchChatMessages(chatId: Int!, query: String!, last: Int, before: Cursor): [MessageEdge!]!

    """
    Case-insensitively `query`s every text messages, poll message title and options, action message text and actions,
    and pic message captions in every chat the user is in. Each item in the returned `ChatMessages` will be for a
    particular `ChatMessages.chat`, and have the `ChatMessages.messages` from the search results.

    An access token must be sent with this request.
    """
    searchMessages(query: String!): [ChatMessages!]!

    """
    Returns the user's account info.

    An access token must be sent with this request.
    """
    readAccount: Account!

    """
    Returns the chats the user is in.

    An access token must be sent with this request.
    """
    readChats: [Chat!]!

    """
    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"`.

    An access token must be sent with this request if the chat being read isn't a public chat.
    """
    readChat(id: Int!): Chat!

    """
    Returns the `GroupChatInfo` the `inviteCode` is for.

    Returned `errors[0].message`s could be `"INVALID_INVITE_CODE"` (i.e., the invite code doesn't exist).
    """
    readGroupChat(inviteCode: Uuid!): GroupChatInfo!

    """
    Case-insensitively searches group chats and private chats the user is in. Private chats are searched by matching the
    `query` with the username, first name, and last name of users the user has chats with. Group chats are searched by
    matching the `query` with the title of group chats the user is in.

    An access token must be sent with this request.
    """
    searchChats(query: String!): [Chat!]!

    """Case-insensitively searches chats by case-insensitively `query`ing their titles."""
    searchPublicChats(query: String!): [GroupChat!]!

    """
    Retrieves saved contacts.

    An access token must be sent with this request.
    """
    readContacts(first: Int, after: Cursor): AccountsConnection!

    """
    Case-insensitively searches contacts by `query`ing their usernames, first names, last names, and email addresses.

    An access token must be sent with this request.
    """
    searchContacts(query: String!, first: Int, after: Cursor): AccountsConnection!

    """
    Operations such as `Query.updateAccount` require authentication via an access token. An access token can be acquired
    by passing the user's `Login` to this operation. Once the access token has expired, the `TokenSet.refreshToken` can
    be passed to `Query.refreshTokenSet`.

    Returned `errors[0].message`s could be `"NONEXISTENT_USER"` (i.e., the username doesn't exist),
    `"UNVERIFIED_EMAIL_ADDRESS"`, or `"INCORRECT_PASSWORD"`.
    """
    requestTokenSet(login: Login!): TokenSet!

    """
    The access token is short-lived. Once it expires, the user would have to log in again. This can be avoided by
    passing the `TokenSet.refreshToken` from `Query.requestTokenSet` as the `refreshToken` to request a new `TokenSet`.
    """
    refreshTokenSet(refreshToken: ID!): TokenSet!

    """
    Searches users. The `query` is case-insensitively matched against users' usernames, email addresses, first names,
    and last names. Returns the users found.
    """
    searchUsers(query: String!, first: Int, after: Cursor): AccountsConnection!
}

type Mutation {
    """
    Blocks the `id`. Does nothing if the user has already been blocked, or the user is blocking themselves.

    Returned `errors[0].message`s could be `"INVALID_USER_ID"` (i.e., the user ID doesn't exist).

    An access token must be sent with this request.
    """
    blockUser(id: Int!): Placeholder!

    """
    Unblocks the `id`. Does nothing if the user wasn't blocked.

    An access token must be sent with this request.
    """
    unblockUser(id: Int!): Placeholder!

    """
    Deletes the user's account. All the user's data will be wiped from the system. This means that users in private
    chats with the user will have their chats deleted, etc.

    The only reason the account cannot be deleted is if the user is the only admin of a group chat containing users
    other than themselves. In this case, they must first appoint a different user as an admin.

    Returned `errors[0].message`s could be `"CANNOT_DELETE_ACCOUNT"`.

    An access token must be sent with this request.
    """
    deleteAccount: Placeholder!

    """
    When a user creates an account, or updates their email address, they'll receive an email with a `verificationCode`
    which must be passed to this operation in order to verify their email address. If the `verificationCode` is valid,
    the account's email address verification status will be set to verified, and `true` will be returned. Otherwise,
    `false` will be returned. Use `Mutation.emailEmailAddressVerification` if the user lost their verification code.

    Returned `errors[0].message`s could be `"UNREGISTERED_EMAIL_ADDRESS"` (i.e., the `emailAddress` isn't associated
    with an account).
    """
    verifyEmailAddress(emailAddress: String!, verificationCode: Int!): Boolean!

    """
    Updates the password of the account associated with the `emailAddress` to the `newPassword` if the
    `passwordResetCode` is correct, and returns `true`. Otherwise, `false` is returned.

    Returned `errors[0].message`s could be `"UNREGISTERED_EMAIL_ADDRESS"` (i.e., the `emailAddress` isn't associated
    with an account).
    """
    resetPassword(emailAddress: String!, passwordResetCode: Int!, newPassword: Password!): Boolean!

    """
    Stars the `messageId`. The user can star their own messages. Starring an already starred message will do nothing.

    Returned `errors[0].message`s could be `"INVALID_MESSAGE_ID"` (i.e., the `messageId` doesn't exist for the user).

    An access token must be sent with this request.
    """
    star(messageId: Int!): Placeholder!

    """
    Unstars the `messageId`. Does nothing if the message wasn't starred.

    An access token must be sent with this request.
    """
    deleteStar(messageId: Int!): Placeholder!

    """
    Sets the current user's status to `isOnline`.

    An access token must be sent with this request.
    """
    setOnline(isOnline: Boolean!): Placeholder!

    """
    Sets whether the user `isTyping` in the `chatId`.

    Let's consider an example use case. Once the user starts typing, the other users in the chat will see a typing
    status on the user. Once the user stops typing for more than two seconds, the typing status will be removed.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    An access token must be sent with this request.
    """
    setTyping(chatId: Int!, isTyping: Boolean!): Placeholder!

    """
    Deletes the user's profile pic.

    An access token must be sent with this request.
    """
    deleteProfilePic: Placeholder!

    """
    Deletes the group chat's profile pic. The user must be the admin.

    An access token must be sent with this request.
    """
    deleteGroupChatPic(chatId: Int!): Placeholder!

    """
    Records that the user received or read the `messageId`. If the `status` is `MessageStatus.READ`, and there's no
    `MessageStatus.DELIVERED` record, the delivery status will be created. Nothing will happen if the status was already
    created.

    Returned `errors[0].message`s could be `"INVALID_MESSAGE_ID"` (i.e., the message doesn't exist in a chat the user is
    in, or the message is the user's own).

    An access token must be sent with this request.
    """
    createStatus(messageId: Int!, status: MessageStatus!): Placeholder!

    """
    Updates the user's account. Only the non-null fields will be updated. None of the updates will take place if even
    one of the fields were invalid. If the user updates their email address to something other than their current
    address, they must be loged out because the current access token will be invalid until they verify their new email
    address.

    If the user updates their email address, they'll be required to verify it before their next login via an email which
    is sent to it. This means they'll be locked out of their account if they provide an invalid address, and will have
    to contact the service's admin to correctly update their address. This mistake can be prevented by asking them to
    confirm their address. For example, a UI could require the user to enter their email address twice if they're
    updating it, and only allow the update to take place if both the entered addresses match.

    Returned `errors[0].message`s could be `"USERNAME_TAKEN"`, or `"EMAIL_ADDRESS_TAKEN"`.

    An access token must be sent with this request.
    """
    updateAccount(update: AccountUpdate!): Placeholder!

    """
    Creates an account, and sends the user a verification email. The user will not be allowed to log in until they
    verify their email address. Use `Mutation.verifyEmailAddress` to verify the user's email address.

    Returned `errors[0].message`s could be `"USERNAME_TAKEN"`, `"EMAIL_ADDRESS_TAKEN"`, or `"INVALID_DOMAIN"` (i.e.,
    this Omni Chat instance disallows the given `AccountInput.emailAddress`'s domain; for example,
    `"johndoe@private.company.com"` may be allowed, but not `"johndoe@gmail.com"`).
    """
    createAccount(account: AccountInput!): Placeholder!

    """
    Sends the user an email to verify their `emailAddress`. An example use case for this operation is when the user
    created an account (which caused an email address verification email to be sent) but accidentally deleted the email,
    and therefore requires it to be resent.

    Returned `errors[0].message`s could be `"UNREGISTERED_EMAIL_ADDRESS"`, or `"EMAIL_ADDRESS_VERIFIED"` (i.e., the
    `emailAddress` is already verified).
    """
    emailEmailAddressVerification(emailAddress: String!): Placeholder!

    """
    Sends a password reset email to the supplied `emailAddress`. The email will contain a password reset code which must
    then be passed to `Mutation.resetPassword`. If the user is logged in (i.e., an access token is present), and wants
    to update their password, `Mutation.updateAccount` should be used instead.

    Returned `errors[0].message`s could be `"UNREGISTERED_EMAIL_ADDRESS"`.
    """
    emailPasswordResetCode(emailAddress: String!): Placeholder!

    """An access token must be sent with this request. Only an admin can perform this operation."""
    updateGroupChatTitle(chatId: Int!, title: GroupChatTitle!): Placeholder!

    """An access token must be sent with this request. Only an admin can perform this operation."""
    updateGroupChatDescription(chatId: Int!, description: GroupChatDescription!): Placeholder!

    """
    Nonexistent users, and users who are already in the chat will be ignored.

    An access token must be sent with this request. Only an admin can perform this operation.
    """
    addGroupChatUsers(chatId: Int!, idList: [Int!]!): Placeholder!

    """
    Messages sent by, and polls voted on, by removed users will remain. Nonexistent users, and users who aren't in the
    chat will be ignored.

    Returned `errors[0].message`s could be `"INVALID_USER_ID"` (i.e., the user attempted to leave the chat but they
    must first appoint another user as an admin because they're the last admin of an otherwise nonempty chat).

    An access token must be sent with this request. Only an admin can perform this operation.
    """
    removeGroupChatUsers(chatId: Int!, idList: [Int!]!): Placeholder!

    """
    Makes every user in the `idList` an admin of the `chatId`. Nonexistent users, users who aren't in the chat, and
    users who are already admins, are ignored.

    An access token must be sent with this request. Only an admin can perform this operation.
    """
    makeGroupChatAdmins(chatId: Int!, idList: [Int!]!): Placeholder!

    """
    Creates a group chat. Nonexistent users are ignored. The `chat` parameter's `GroupChatInput.userIdList` and
    `GroupChatInput.adminIdList` needn't contain the user's own ID, as it is implicitly included. The created chat's ID
    is returned.

    Returned `errors[0].message`s could be `"INVALID_ADMIN_ID"` (i.e., the `chat` parameter's
    `GroupChatInput.adminIdList` wasn't a subset of the `GroupChatInput.userIdList`).

    An access token must be sent with this request.
    """
    createGroupChat(chat: GroupChatInput!): Int!

    """
    Sets whether the `chatId` `isBroadcast`. The user must be an admin to perform this operation.

    An access token must be sent with this request.
    """
    setBroadcast(chatId: Int!, isBroadcast: Boolean!): Placeholder!

    """
    The user must be an admin to perform this operation.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the chat isn't a group chat chat, or the chat is a
    public chat).

    An access token must be sent with this request.
    """
    setInvitability(chatId: Int!, isInvitable: Boolean!): Placeholder!

    """
    Joins the chat the `inviteCode` is for. Nothing will happen if the user is already in the chat.

    Returned `errors[0].message`s could be `"INVALID_INVITE_CODE"` (i.e., the invite code doesn't exist).

    An access token must be sent with this request.
    """
    joinGroupChat(inviteCode: Uuid!): Placeholder!

    """
    Deletes a private chat.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    An access token must be sent with this request.
    """
    deletePrivateChat(chatId: Int!): Placeholder!

    """
    Creates a private chat with the `userId` if the chat doesn't exist. Returns the chat's ID.

    Returned `errors[0].message`s could be `"INVALID_USER_ID"` (i.e., the specified user doesn't exist).

    An access token must be sent with this request.
    """
    createPrivateChat(userId: Int!): Int!

    """
    Sends the `text` in the `chatId`. If the `chatId` is a broadcast chat, the user must be an admin to message. The
    user might want to give their message a context, such as when replying to a message sent several messages ago. In
    this case, the `contextMessageId` is to be the ID of the message being replied to.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat), or
    `"INVALID_MESSAGE_ID"` (i.e., the `contextMessageId` doesn't exist).

    An access token must be sent with this request.
    """
    createTextMessage(chatId: Int!, text: MessageText!, contextMessageId: Int): Placeholder!

    """
    Sends the `text` in the `chatId`. For example, a restaurant's bot asks if the user wants a burger or a pizza in the
    `text`, and the `actions` are `"burger"` and `"pizza"`. If the `chatId` is a broadcast chat, the user must be an
    admin to message. The user might want to give their message a context, such as when replying to a message sent
    several messages ago. In this case, the `contextMessageId` is to be the ID of the message being replied to.

    A frontend UI could display this message like a regular text message but with buttons below it. Action messages are
    meant for bots; human users shouldn't be able to create them. Only the creator of the action message will be
    notified when `Mutation.triggerAction` gets called.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat), `"INVALID_ACTION"`
    (i.e., either there were zero `actions` or the `actions` weren't unique), or `"INVALID_MESSAGE_ID"` (i.e., the
    `contextMessageId` doesn't exist).

    An access token must be sent with this request.
    """
    createActionMessage(chatId: Int!, message: ActionMessageInput!, contextMessageId: Int): Placeholder!

    """
    Creates a `GroupChatInviteMessage` in the `chatId` inviting users to join the `invitedChatId`. If the `chatId` is a
    broadcast chat, the user must be an admin to message. The user might want to give their message a context, such as
    when replying to a message sent several messages ago. In this case, the `contextMessageId` is to be the ID of the
    message being replied to. A frontend UI might want to hide the `GroupChatInviteMessage.inviteCode`, and instead
    display the `GroupChatInfo`.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the `chatId`),
    `"INVALID_INVITED_CHAT"` (i.e., the `invitedChatId` isn't a group chat, or the chat has invitations turned off),
    or `"INVALID_MESSAGE_ID"` (i.e., the `contextMessageId` doesn't exist).

    An access token must be sent with this request.
    """
    createGroupChatInviteMessage(chatId: Int!, invitedChatId: Int!, contextMessageId: Int): Placeholder!

    """
    Sends the `poll` in the `chatId`. If the `chatId` is a broadcast chat, the user must be an admin to message. The
    user might want to give their message a context, such as when replying to a message sent several messages ago. In
    this case, the `contextMessageId` is to be the ID of the message being replied to.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat),
    `"INVALID_MESSAGE_ID"` (i.e., the `contextMessageId` doesn't exist), or `"INVALID_POLL"` (i.e., there were less than
    two options, or an option was duplicated).

    An access token must be sent with this request.
    """
    createPollMessage(chatId: Int!, poll: PollInput!, contextMessageId: Int): Placeholder!

    """
    Forwards the `messageId` to the `chatId`. If the `chatId` is a broadcast chat, the user must be an admin to message.
    The user might want to give their message a context, such as when replying to a message sent several messages ago.
    In this case, the `contextMessageId` is to be the ID of the message being replied to.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat), or
    `"INVALID_MESSAGE_ID"` (i.e., `messageId` or `contextMessageId` doesn't exist).

    An access token must be sent with this request.
    """
    forwardMessage(chatId: Int!, messageId: Int!, contextMessageId: Int): Placeholder!

    """
    Triggers the `action` on the `messageId`'s action message.

    Returned `errors[0].message`s could be `"INVALID_MESSAGE_ID"` (i.e., there's no such action message), or
    `"INVALID_ACTION"` (i.e., the `action` doesn't exist).

    An access token must be sent with this request.
    """
    triggerAction(messageId: Int!, action: MessageText!): Placeholder!

    """
    Updates the user's vote for the `option` on the `messageId`'s poll. If `vote` is `true`, the user's vote will be
    added if it hasn't already. If `vote` is `false`, the user's vote will be removed if there is one.

    Returned `errors[0].message`s could be `"INVALID_MESSAGE_ID"` (i.e., there's no such poll message), or
    `"NONEXISTENT_OPTION"` (i.e., the `option` isn't in the poll).

    An access token must be sent with this request.
    """
    setPollVote(messageId: Int!, option: MessageText!, vote: Boolean!): Placeholder!

    """
    Deletes the message `id` from the chat it's from. The user can only delete their own messages.

    Returned `errors[0].message`s could be `"INVALID_MESSAGE_ID"` (i.e., the message isn't in a chat the user is in, the
    message isn't visible to the user because they deleted the private chat, or the message isn't the user's own).

    An access token must be sent with this request.
    """
    deleteMessage(id: Int!): Placeholder!

    """
    Remove saved contacts. Invalid contacts (e.g., invalid user IDs, unsaved contacts) will be ignored.

    An access token must be sent with this request.
    """
    deleteContacts(idList: [Int!]!): Placeholder!

    """
    Saves contacts. Previously saved contacts, nonexistent users, and the user's own ID will be ignored.

    An access token must be sent with this request.
    """
    createContacts(idList: [Int!]!): Placeholder!
}

type Subscription {
    """
    Yields created, updated, and deleted messages (including the user's own messages) in every chat the user is in. A
    message from a chat the user wasn't previously in can be sent as well (e.g., when the other user in a private chat
    the user deleted sends a message in it). The subscription will be stopped if the user deletes their account.

    An access token must be sent with this request.
    """
    subscribeToMessages: MessagesSubscription!

    """
    Yields the online statuses of users the user has in their contacts, or has a chat with. The subscription will be
    stopped if the user deletes their account.

    An access token must be sent with this request.
    """
    subscribeToOnlineStatuses: OnlineStatusesSubscription!

    """
    Yields typing statuses for chats the user has. The user's own typing statuses won't be yielded. The subscription
    will be stopped if the user deletes their account.

    An access token must be sent with this request.
    """
    subscribeToTypingStatuses: TypingStatusesSubscription!

    """
    Yields updates on the user's contacts, the subscriber's account, and accounts of users the subscriber has a chat
    with. The subscription will be stopped if the user deletes their account.

    An access token must be sent with this request.
    """
    subscribeToAccounts: AccountsSubscription!

    """
    Yields group chats the user was added to (including chats they created), and group chat metadata updates. The
    subscription will be stopped if the user deletes their account.

    An access token must be sent with this request.
    """
    subscribeToGroupChats: GroupChatsSubscription!
}

union MessagesSubscription =
    | CreatedSubscription
    | NewTextMessage
    | NewActionMessage
    | NewPicMessage
    | NewAudioMessage
    | NewGroupChatInviteMessage
    | NewDocMessage
    | NewVideoMessage
    | NewPollMessage
    | UpdatedTextMessage
    | UpdatedActionMessage
    | UpdatedPicMessage
    | UpdatedAudioMessage
    | UpdatedGroupChatInviteMessage
    | UpdatedDocMessage
    | UpdatedVideoMessage
    | UpdatedPollMessage
    | TriggeredAction
    | DeletedMessage
    | MessageDeletionPoint
    | DeletionOfEveryMessage
    | UserChatMessagesRemoval

union OnlineStatusesSubscription = CreatedSubscription | UpdatedOnlineStatus

union TypingStatusesSubscription = CreatedSubscription | TypingStatus

"""
A user will be automatically unblocked when they delete their account. In this scenario, an `UnblockedAccount` will not
be sent because it's a rare event, and the client would've had to deal with the user viewing a user who's account was
just deleted.
"""
union AccountsSubscription =
    | CreatedSubscription
    | NewContact
    | UpdatedAccount
    | UpdatedProfilePic
    | DeletedContact
    | BlockedAccount
    | UnblockedAccount

"""The `id` of the user who updated their profile pic."""
type UpdatedProfilePic {
    id: Int!
}

"""
A `GroupChatId` is the ID of the chat the user was added to.

If the subscriber leaves the chat, they will receive their own `ExitedUser` message.
"""
union GroupChatsSubscription = CreatedSubscription | GroupChatId | UpdatedGroupChatPic |  UpdatedGroupChat | ExitedUser

"""The `id` of the group chat whose pic was updated."""
type UpdatedGroupChatPic {
    id: Int!
}

"""
The `action` on the action `messageId` which was `triggeredBy` the user. This will only be sent to the user who created
the action message.
"""
type TriggeredAction {
    messageId: Int!
    action: MessageText!
    triggeredBy: Account!
}

type UpdatedOnlineStatus {
    userId: Int!
    isOnline: Boolean!
    """`null` if the `userId` has never set an online status."""
    lastOnline: DateTime
}

type OnlineStatus {
    userId: Int!
    isOnline: Boolean!
    """`null` if the `userId` has never set an online status."""
    lastOnline: DateTime
}

"""Whether the `userId` `isTyping` in the `chatId`."""
type TypingStatus {
    chatId: Int!
    userId: Int!
    isTyping: Boolean!
}

type GroupChatId {
    id: Int!
}

"""The user who left the group chat."""
type ExitedUser {
    chatId: Int!
    userId: Int!
}

"""null fields correspond to the field not existing. This will not be sent if the profile pic was updated."""
type UpdatedAccount {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""
Null fields haven't been updated. If a non-null field hasn't been updated, its value will be the same as before. This
will not be sent if the pic has been updated.
"""
type UpdatedGroupChat {
    chatId: Int!
    title: GroupChatTitle
    description: GroupChatDescription
    newUsers: [Account!]
    removedUsers: [Account!]
    adminIdList: [Int!]
    isBroadcast: Boolean
    publicity: GroupChatPublicity
}

"""
Every message in the `chatId` has been deleted.

This happens in private chats when the user deleted it, or the other user deleted their account. This happens in group
chats when the last user left the chat.
"""
type DeletionOfEveryMessage {
    chatId: Int!
}

"""
Every message the `userId` sent in the `chatId` has been deleted. This happens when a group chat's member deletes their
account.
"""
type UserChatMessagesRemoval {
    chatId: Int!
    userId: Int!
}

"""
Indicates that the `Subscription` has been created. This will only be sent only once, and will be the first event sent.
"""
type CreatedSubscription {
    placeholder: Placeholder!
}

"""Indicates that the every message `until` the `DateTime` has been deleted in the `chatId`."""
type MessageDeletionPoint {
    chatId: Int!
    until: DateTime!
}

"""The `messageId` has been deleted from the `chatId`."""
type DeletedMessage {
    chatId: Int!
    messageId: Int!
}

input PollInput {
    """For example, `"Where should we meet?"`."""
    title: MessageText!
    """There must be at least two options. Each option must be unique. For example, `["Burger King", "Pizza Hut"]`."""
    options: [MessageText!]!
}

type PollOption {
    option: MessageText!
    """The ID of every user who voted for this."""
    votes: [Int!]!
}

"""A user can vote for each option at most once, but can vote for multiple options."""
type Poll {
    title: MessageText!
    """There are at least two options, each of which are unique."""
    options: [PollOption!]!
}

input ActionMessageInput {
    """For example, `"What would you like to order?"`."""
    text: MessageText!
    """There must be at least one action. Each action must be unique. For example, `["Pizza", "Burger"]`."""
    actions: [MessageText!]!
}

type ActionableMessage {
    text: MessageText!
    """There's at least one action. Each action is unique."""
    actions: [MessageText!]!
}

type AccountsConnection {
    edges: [AccountEdge!]!
    pageInfo: PageInfo!
}

type AccountEdge {
    node: Account!
    cursor: Cursor!
}

interface AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

type Account implements AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""A blocked user."""
type BlockedAccount implements AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""The user `id` of an unblocked user."""
type UnblockedAccount {
    id: Int!
}

type NewContact implements AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: Name!
    lastName: Name!
    bio: Bio!
}

"""
The `id` of the contact which has been deleted for the user. This happens when the user deletes a contact, or the
contact's account gets deleted.
"""
type DeletedContact {
    id: Int!
}

input AccountInput {
    username: Username!
    password: Password!
    emailAddress: String!
    firstName: Name! = ""
    lastName: Name! = ""
    bio: Bio! = ""
}

type ChatMessages {
    chat: Chat!
    messages(last: Int, before: Cursor): [MessageEdge!]!
}

interface Chat {
    id: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
}

type MessagesConnection {
    edges: [MessageEdge!]!
    pageInfo: PageInfo!
}

type MessageEdge {
    node: Message!
    cursor: Cursor!
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: Cursor
    endCursor: Cursor
}

interface BareGroupChat {
    title: GroupChatTitle!
    description: GroupChatDescription!
    """The ID of the `users` who are the admins. There will be at least one admin."""
    adminIdList: [Int!]!
    users(first: Int, after: Cursor): AccountsConnection!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
}

type GroupChatInfo implements BareGroupChat {
    title: GroupChatTitle!
    description: GroupChatDescription!
    adminIdList: [Int!]!
    users(first: Int, after: Cursor): AccountsConnection!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
}

type GroupChat implements Chat, BareGroupChat {
    id: Int!
    title: GroupChatTitle!
    description: GroupChatDescription!
    adminIdList: [Int!]!
    users(first: Int, after: Cursor): AccountsConnection!
    messages(last: Int, before: Cursor): MessagesConnection!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
    """null if invite codes are turned off."""
    inviteCode: Uuid
}

type PrivateChat implements Chat {
    id: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
    """The user being chatted with."""
    user: Account!
}

type MessageContext {
    """Whether this message was in reply to a particular message."""
    hasContext: Boolean!
    """
    The ID of the context message.

    If this message doesn't `hasContext`, this will be null. If this message `hasContext`, this will be null only if the
    context message was deleted. Since this message might not make any sense without the context, if this message
    `hasContext`, but the context message was deleted, a frontend could replace what should've been the context message
    with something similar to "Message deleted".
    """
    id: Int
}

interface BareMessage {
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

interface Message implements BareMessage {
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

type TextMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    message: MessageText!
}

type ActionMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    message: ActionableMessage!
}

type PicMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    caption: MessageText
}

type PollMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    poll: Poll!
}

type AudioMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

type GroupChatInviteMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    inviteCode: Uuid!
}

type DocMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

type VideoMessage implements BareMessage, Message {
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

interface BareChatMessage implements BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

"""The message which the user starred."""
interface StarredMessage implements BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type StarredTextMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    message: MessageText!
}

type StarredActionMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    message: ActionableMessage!
}

type StarredPicMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    caption: MessageText
}

type StarredPollMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    poll: Poll!
}

type StarredAudioMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type StarredGroupChatInviteMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    inviteCode: Uuid!
}

type StarredDocMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type StarredVideoMessage implements StarredMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

interface NewMessage implements BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type NewTextMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    message: MessageText!
}

type NewActionMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    message: ActionableMessage!
}

type NewPicMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    caption: MessageText
}

type NewPollMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    poll: Poll!
}

type NewAudioMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type NewGroupChatInviteMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    inviteCode: Uuid!
}

type NewDocMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

type NewVideoMessage implements NewMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
}

"""An existing `messageId` in the `chatId` which was updated. Only the `dateTimes` would be updated."""
interface UpdatedMessage implements BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

type UpdatedTextMessage implements UpdatedMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    message: MessageText!
}

type UpdatedActionMessage implements UpdatedMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    message: ActionableMessage!
}

type UpdatedPicMessage implements UpdatedMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    caption: MessageText
}

type UpdatedPollMessage implements UpdatedMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    poll: Poll!
}

type UpdatedAudioMessage implements UpdatedMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

type UpdatedGroupChatInviteMessage implements UpdatedMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
    inviteCode: Uuid!
}

type UpdatedDocMessage implements UpdatedMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

type UpdatedVideoMessage implements UpdatedMessage, BareChatMessage, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    dateTimes: MessageDateTimes!
    context: MessageContext!
    isForwarded: Boolean!
    hasStar: Boolean!
}

type MessageDateTimes {
    sent: DateTime!
    statuses: [MessageDateTimeStatus!]!
}

"""The `dateTime` the `user` created the `status`."""
type MessageDateTimeStatus {
    user: Account!
    dateTime: DateTime!
    status: MessageStatus!
}

enum MessageStatus {
    DELIVERED
    READ
}

enum GroupChatPublicity {
    """Users cannot join the chat via an invite code."""
    NOT_INVITABLE
    """Users can join the chat via an invite code."""
    INVITABLE
    """
    People can search for, and view public chats without an account. Invite codes are permanently turned on. Anyone
    with an account can join a public chat. A frontend UI may allow for a search engine to index the chat should the
    administrator allow for it. A chat must be made public when it's being created because chats can't switch between
    being public after they've been created.
    """
    PUBLIC
}

type TokenSet {
    accessToken: ID!
    refreshToken: ID!
}

input Login {
    username: Username!
    password: Password!
}

"""Only non-null fields will be updated."""
input AccountUpdate {
    username: Username
    password: Password
    emailAddress: String
    firstName: Name
    lastName: Name
    bio: Bio
}

input GroupChatInput {
    title: GroupChatTitle!
    description: GroupChatDescription!
    userIdList: [Int!]!
    adminIdList: [Int!]!
    isBroadcast: Boolean!
    publicity: GroupChatPublicity!
}
