"""Complies with ISO 8601."""
scalar DateTime

"""A cursor for pagination."""
scalar Cursor

"""A username which has non-whitespace characters, is less than 256 characters, and is lowercase."""
scalar Username

"""A user's bio which cannot exceed 2,500 characters, and uses CommonMark."""
scalar Bio

"""A password which contains non-whitespace characters."""
scalar Password

"""1-70 characters, of which at least one isn't whitespace."""
scalar GroupChatTitle

"""At most 1,000 characters, and uses CommonMark. An empty string corresponds to no description."""
scalar GroupChatDescription

"""1-10,000 characters, of which at least one isn't whitespace. Uses CommonMark."""
scalar TextMessage

"""
GraphQL mandates data be returned for every operation, and data be present in every type. However, certain operations
and types don't have relevant data. This type, which is an empty `String`, indicates such.
"""
scalar Placeholder

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

type Query {
    """
    Returns whether the user's account can be deleted. The only reason the account cannot be deleted is if the user is
    the only admin of a group chat containing users other than themselves. In this case, they must first appoint a
    different user as the admin.

    You must send an access token with this request.
    """
    canDeleteAccount: Boolean!

    """
    Returns the user's starred messages.

    You must send an access token with this request.
    """
    readStars: [StarredMessage!]!

    """
    The online statuses of users the user has in their contacts, or is in a chat with.

    You must send an access token with this request.
    """
    readOnlineStatuses: [OnlineStatus!]!

    """
    Case-insensitively `query`s text messages in the `chatId`.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    You must send an access token with this request.
    """
    searchChatMessages(chatId: Int!, query: String!, last: Int, before: Cursor): [MessageEdge!]!

    """
    Case-insensitively `query`s every text message in every chat the user is in. Each item in the returned
    `ChatMessages` will be for a particular `ChatMessages.chat`, and have the `ChatMessages.messages` from the search
    results.

    You must send an access token with this request.
    """
    searchMessages(query: String!): [ChatMessages!]!

    """
    Returns the user's account info.

    You must send an access token with this request.
    """
    readAccount: Account!

    """Returns whether the `username` has been taken."""
    isUsernameTaken(username: Username!): Boolean!

    """Returns whether the `emailAddress` has been taken."""
    isEmailAddressTaken(emailAddress: String!): Boolean!

    """
    Returns the chats the user is in.

    You must send an access token with this request.
    """
    readChats: [Chat!]!

    """
    Returns the chat `id`.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"`.

    You must send an access token with this request.
    """
    readChat(id: Int!): Chat!

    """
    Case-insensitively searches group chats and private chats. Private chats are searched by matching the `query` with
    the username, first name, and last name of users the user has chats with. Group chats are searched by matching the
    `query` with the title of group chats the user is in.

    You must send an access token with this request.
    """
    searchChats(query: String!): [Chat!]!

    """
    Retrieves saved contacts.

    You must send an access token with this request.
    """
    readContacts(first: Int, after: Cursor): AccountsConnection!

    """
    Case-insensitively searches contacts using the `query`.

    You must send an access token with this request.
    """
    searchContacts(query: String!, first: Int, after: Cursor): AccountsConnection!

    """
    Operations such as `Query.updateAccount` require authentication via an access token. You can acquire one to
    authenticate the user by passing their `Login` to this operation.

    Returned `errors[0].message`s could be `"NONEXISTENT_USER"` (i.e., the username doesn't exist),
    `"UNVERIFIED_EMAIL_ADDRESS"`, or `"INCORRECT_PASSWORD"`.
    """
    requestTokenSet(login: Login!): TokenSet!

    """
    The access token is short-lived. Once it expires, the user would have to log in again. This can be avoided by
    passing the `refreshToken` to this operation to request a new set of tokens.
    """
    refreshTokenSet(refreshToken: ID!): TokenSet!

    """
    Searches users. The `query` is case-insensitively matched against users' usernames, email addresses, first names,
    and last names. Returns the users found.
    """
    searchUsers(query: String!, first: Int, after: Cursor): AccountsConnection!
}

type Mutation {
    """
    Deletes the user's account. All the user's data will be wiped from the system. This means that users in private
    chats with the user will have their chats deleted, etc.

    Returned `errors[0].message`s could be `"CANNOT_DELETE_ACCOUNT"` (i.e., if not `Query.canDeleteAccount`).

    You must send an access token with this request.
    """
    deleteAccount: Placeholder!

    """
    Stars the `messageId`. You can star your own messages. Starring an already starred message will do nothing.

    Returned `errors[0].message`s could be `"INVALID_MESSAGE_ID"` (i.e., the `messageId` doesn't exist for the user).

    You must send an access token with this request.
    """
    star(messageId: Int!): Placeholder!

    """
    Unstars the `messageId`. Does nothing if the message wasn't starred.

    You must send an access token with this request.
    """
    deleteStar(messageId: Int!): Placeholder!

    """
    Sets the current user's status to `isOnline`.

    You must send an access token with this request.
    """
    setOnlineStatus(isOnline: Boolean!): Placeholder!

    """
    Sets whether the user `isTyping` in the `chatId`.

    Let's consider an example use case. Once the user starts typing, the other users in the chat will see a typing
    status on the user. Once the user stops typing for more than two seconds, the typing status will be removed.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    You must send an access token with this request.
    """
    setTyping(chatId: Int!, isTyping: Boolean!): Placeholder!

    """
    Deletes the user's profile pic.

    You must send an access token with this request.
    """
    deleteProfilePic: Placeholder!

    """
    Deletes the group chat's profile pic. The user must be the admin.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"`.

    You must send an access token with this request.
    """
    deleteGroupChatPic(chatId: Int!): Placeholder!

    """
    Records that the user received or read the `messageId`. If the `status` is `MessageStatus.READ`, and there's no
    `MessageStatus.DELIVERED` record, the delivery status will be created.

    Returned `errors[0].message`s could be `"INVALID_MESSAGE_ID"` (i.e., the message doesn't exist in a chat the user is
    in, or the message is the user's own), or `"DUPLICATE_STATUS"` (i.e., you have already told the server that the user
    had the message delivered to them).

    You must send an access token with this request.
    """
    createStatus(messageId: Int!, status: MessageStatus!): Placeholder!

    """
    Updates the user's account. Only the non-null fields will be updated. Use `Query.isUsernameTaken` and
    `Query.isEmailAddressTaken` to see whether you can update the `AccountUpdate.username` and
    `AccountUpdate.emailAddress` fields to the requested ones respectively. None of the updates will take place if even
    one of the fields were invalid.

    If the user updates their email address, they'll be required to verify it before their next login via an email which
    is sent to it. This means they'll be locked out of their account if they provide an invalid address, and will have
    to contact the service's admin to correctly update their address. You could prevent this mistake by asking them to
    confirm their address. For example, a UI could require the user to enter their email address twice if they're
    updating it, and only allow the update to take place if both the entered addresses match.

    Returned `errors[0].message`s could be `"USERNAME_TAKEN"`, or `"EMAIL_ADDRESS_TAKEN"`.

    You must send an access token with this request.
    """
    updateAccount(update: AccountUpdate!): Placeholder!

    """
    Creates an account, and sends the user a verification email. The user will not be allowed to log in until they
    verify their email address. Use `Query.isUsernameTaken` and `Query.isEmailAddressTaken` to see whether you can use
    the requested `NewAccount.username` and `NewAccount.emailAddress` fields respectively.

    Returned `errors[0].message`s could be `"USERNAME_TAKEN"`, or `"EMAIL_ADDRESS_TAKEN"`.
    """
    createAccount(account: AccountInput!): Placeholder!

    """
    Sends the user an email to verify their email `address`. For example, the user may want the email verification to be
    resent because the one which was automatically sent when their account was created timed out. Use
    `Query.isEmailAddressTaken` to check whether the supplied `email` address exists.

    Returned `errors[0].message`s could be `"UNREGISTERED_EMAIL_ADDRESS"`.
    """
    sendEmailAddressVerification(emailAddress: String!): Placeholder!

    """
    Sends a password reset email to the supplied `address`. Use `Query.isEmailAddressTaken` to check whether the
    supplied `address` address exists. If the user is logged in (i.e., you have an access token), and wants to update
    their password, you should use `Mutation.updateAccount` instead.

    Returned `errors[0].message`s could be `"UNREGISTERED_EMAIL_ADDRESS"`.
    """
    resetPassword(emailAddress: String!): Placeholder!

    """
    Only an admin can perform this operation.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    You must send an access token with this request.
    """
    updateGroupChatTitle(chatId: Int!, title: GroupChatTitle!): Placeholder!

    """
    Only an admin can perform this operation.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    You must send an access token with this request.
    """
    updateGroupChatDescription(chatId: Int!, description: GroupChatDescription!): Placeholder!

    """
    Users already in the chat will be ignored. Only an admin can perform this operation.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat), or
    `"INVALID_USER_ID"` (i.e., a user to be added to the chat doesn't exist).

    You must send an access token with this request.
    """
    addGroupChatUsers(chatId: Int!, userIdList: [Int!]!): Placeholder!

    """
    Only an admin can perform this operation.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat), or
    `"INVALID_USER_ID"` (i.e., one of the users to be removed isn't in the chat, or the user must first appoint another
    user as an admin because they're the last admin).

    You must send an access token with this request.
    """
    removeGroupChatUsers(chatId: Int!, userIdList: [Int!]!): Placeholder!

    """
    Makes every user in the `userIdList` an admin of the `chatId`. If the `userId`'s already an admin, nothing will
    happen. Only an admin can perform this operation.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat), `"INVALID_USER_ID"`
    (i.e., one of the users in the `userIdList` isn't in the chat).

    You must send an access token with this request.
    """
    makeGroupChatAdmins(chatId: Int!, userIdList: [Int!]!): Placeholder!

    """
    Creates a group chat. The `chat` parameter's `GroupChatInput.userIdList` and `GroupChatInput.adminIdList` needn't
    contain the user's own ID, as it is implicitly included. The created chat's ID is returned.

    Returned `errors[0].message`s could be `"INVALID_USER_ID"` (i.e., one of the participants' IDs don't exist), or
    `"INVALID_ADMIN_ID"` (i.e., the `chat` parameter's `GroupChatInput.adminIdList` wasn't a subset of the
    `GroupChatInput.userIdList`).

    You must send an access token with this request.
    """
    createGroupChat(chat: GroupChatInput!): Int!

    """
    Deletes a private chat.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    You must send an access token with this request.
    """
    deletePrivateChat(chatId: Int!): Placeholder!

    """
    Creates a private chat with the `userId`. Returns the chat's ID.

    Returned `errors[0].message`s could be `"CHAT_EXISTS"`, or `"INVALID_USER_ID"` (i.e., the specified user doesn't
    exist).

    You must send an access token with this request.
    """
    createPrivateChat(userId: Int!): Int!

    """
    Sends the `text` in the `chatId`.

    The user might want to give their message a context, such as when replying to a message sent several messages ago.
    In this case, the `contextMessageId` is to be the ID of the message being replied to.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat), or
    `"INVALID_MESSAGE_ID"` (i.e., the `contextMessageId` didn't exist).

    You must send an access token with this request.
    """
    createMessage(chatId: Int!, text: TextMessage!, contextMessageId: Int): Placeholder!

    """
    Deletes the message `id` from the chat it's from. The user can only delete their own messages.

    Returned `errors[0].message`s could be `"INVALID_MESSAGE_ID"` (i.e., the message isn't in a chat the user is in, the
    message isn't visible to the user because they deleted the private chat, or the message isn't the user's own).

    You must send an access token with this request.
    """
    deleteMessage(id: Int!): Placeholder!

    """
    Remove saved contacts. Invalid contacts (e.g., invalid user IDs, unsaved contacts) will be ignored.

    You must send an access token with this request.
    """
    deleteContacts(userIdList: [Int!]!): Placeholder!

    """
    Saves contacts. Contacts previously saved will be ignored. If the user's own contact is present, it will be ignored.
    Existing contacts will be ignored.

    Returned `errors[0].message`s could be `"INVALID_CONTACT"` (i.e., one of the user IDs didn't exist).

    You must send an access token with this request.
    """
    createContacts(userIdList: [Int!]!): Placeholder!
}

type Subscription {
    """
    Yields created, updated, and deleted messages (including your own) in every chat the user is in. A message from a
    chat the user wasn't previously in can be sent as well (e.g., when the other user in a private chat the user deleted
    sends a message in it). The subscription will be stopped if the user deletes their account.

    You must send an access token with this request.
    """
    subscribeToMessages: MessagesSubscription!

    """
    Yields the online statuses of users the user has in their contacts, or is in a chat with. The subscription will be
    stopped if the user deletes their account.

    You must send an access token with this request.
    """
    subscribeToOnlineStatuses: OnlineStatusesSubscription!

    """
    Yields typing statuses for chats the user has. The user's own typing statuses won't be yielded. The subscription
    will be stopped if the user deletes their account.

    You must send an access token with this request.
    """
    subscribeToTypingStatuses: TypingStatusesSubscription!

    """
    Yields updates on the user's contacts. The subscription will be stopped if the user deletes their account. The
    subscription will be stopped if the user deletes their account.

    You must send an access token with this request.
    """
    subscribeToContacts: ContactsSubscription!

    """
    Yields updated accounts of users the user has private chats with, and metadata updates on group chats the user is
    in. Updates will be sent for private chats the user has deleted because it's possible that the user recreated the
    chat but hasn't finished sending a message in it yet. The subscription will be stopped if the user deletes their
    account.

    You must send an access token with this request.
    """
    subscribeToUpdatedChats: UpdatedChatsSubscription!

    """
    Yields group chats the user was added to. The subscription will be stopped if the user deletes their account.

    You must send an access token with this request.
    """
    subscribeToNewGroupChats: NewGroupChatsSubscription!
}

union MessagesSubscription = CreatedSubscription
    | NewMessage
    | UpdatedMessage
    | DeletedMessage
    | MessageDeletionPoint
    | DeletionOfEveryMessage
    | UserChatMessagesRemoval

union OnlineStatusesSubscription = CreatedSubscription | UpdatedOnlineStatus

union TypingStatusesSubscription = CreatedSubscription | TypingStatus

"""An `UpdatedContact` might be sent if the contact's profile pic was updated."""
union ContactsSubscription = CreatedSubscription | NewContact | UpdatedContact | DeletedContact

"""
An `UpdatedAccount` represents the account of a user which was updated. It's possible the user updated their profile
pic. The subscriber's account updates will not be included.

If the subscriber leaves the chat, they won't receive their own `ExitedUser` message.

An `UpdatedGroupChat` might be sent if the chat's pic was updated.
"""
union UpdatedChatsSubscription = CreatedSubscription | UpdatedGroupChat | UpdatedAccount | ExitedUser

"""A `GroupChatId` is the ID of the chat the user was added to."""
union NewGroupChatsSubscription = CreatedSubscription | GroupChatId

type UpdatedOnlineStatus {
    userId: Int!
    isOnline: Boolean!
}

type OnlineStatus {
    userId: Int!
    isOnline: Boolean!
    """`null` if the `userId` has never set an online status."""
    lastOnline: DateTime
}

"""Whether the `userId` `isTyping` in the `chatId`."""
type TypingStatus {
    chatId: Int!
    userId: Int!
    isTyping: Boolean!
}

type GroupChatId {
    id: Int!
}

"""The user who left the group chat."""
type ExitedUser {
    chatId: Int!
    userId: Int!
}

"""null fields correspond to the field not existing."""
type UpdatedAccount {
    userId: Int!
    username: Username!
    emailAddress: String!
    firstName: String
    lastName: String
    bio: Bio
}

"""Null fields haven't been updated. If a non-null field hasn't been updated, its value will be the same as before."""
type UpdatedGroupChat {
    chatId: Int!
    title: GroupChatTitle
    description: GroupChatDescription
    newUsers: [Account!]
    removedUsers: [Account!]
    adminIdList: [Int!]
}

"""
Every message in the `chatId` has been deleted.

This happens in private chats when the user deleted it, or the other user deleted their account. This happens in group
chats when the last user left the chat.
"""
type DeletionOfEveryMessage {
    chatId: Int!
}

"""
Every message the `userId` sent in the `chatId` has been deleted. This happens when a group chat's member deletes their
account.
"""
type UserChatMessagesRemoval {
    chatId: Int!
    userId: Int!
}

"""
Indicates that the `Subscription` has been created. This will only be sent only once, and will be the first event sent.
"""
type CreatedSubscription {
    placeholder: Placeholder!
}

"""Indicates that the every message `until` the `DateTime` has been deleted in the `chatId`."""
type MessageDeletionPoint {
    chatId: Int!
    until: DateTime!
}

"""The `messageId` has been deleted from the `chatId`."""
type DeletedMessage {
    chatId: Int!
    messageId: Int!
}

type AccountsConnection {
    edges: [AccountEdge!]!
    pageInfo: PageInfo!
}

type AccountEdge {
    node: Account!
    cursor: Cursor!
}

interface AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: String
    lastName: String
    bio: Bio
}

type Account implements AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: String
    lastName: String
    bio: Bio
}

type NewContact implements AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: String
    lastName: String
    bio: Bio
}

type UpdatedContact implements AccountData {
    id: Int!
    username: Username!
    emailAddress: String!
    firstName: String
    lastName: String
    bio: Bio
}

"""
The `id` of the contact which has been deleted for the user. This happens when the user deletes a contact, or the
contact's account gets deleted.
"""
type DeletedContact {
    id: Int!
}

input AccountInput {
    """Must be lowercase."""
    username: Username!
    password: Password!
    emailAddress: String!
    firstName: String
    lastName: String
    bio: Bio
}

type ChatMessages {
    chat: Chat!
    messages(last: Int, before: Cursor): [MessageEdge!]!
}

interface Chat {
    id: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
}

type MessagesConnection {
    edges: [MessageEdge!]!
    pageInfo: PageInfo!
}

type MessageEdge {
    node: Message!
    cursor: Cursor!
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: Cursor
    endCursor: Cursor
}

type GroupChat implements Chat {
    id: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
    title: GroupChatTitle!
    description: GroupChatDescription!
    """The ID of the `users` who are the admins. There will be at least one admin."""
    adminIdList: [Int!]!
    users(first: Int, after: Cursor): AccountsConnection!
}

type PrivateChat implements Chat {
    id: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
    """The user being chatted with."""
    user: Account!
}

interface BareMessage {
    sender: Account!
    text: TextMessage!
    dateTimes: MessageDateTimes!
    context: MessageContext!
}

type MessageContext {
    """Whether this message was in reply to a particular message."""
    hasContext: Boolean!
    """
    The ID of the context message.

    If this message doesn't `hasContext`, this will be null. If this message `hasContext`, this will be null only if the
    context message was deleted. Since this message might not make any sense without the context, if this message
    `hasContext`, but the context message was deleted, a frontend could replace what should've been the context message
    with something similar to "Message deleted".
    """
    id: Int
}

type Message implements BareMessage {
    id: Int!
    sender: Account!
    text: TextMessage!
    dateTimes: MessageDateTimes!
    hasStar: Boolean!
    context: MessageContext!
}

interface MessageData implements BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    text: TextMessage!
    dateTimes: MessageDateTimes!
    context: MessageContext!
}

type StarredMessage implements MessageData, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    text: TextMessage!
    dateTimes: MessageDateTimes!
    context: MessageContext!
}

type NewMessage implements MessageData, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    text: TextMessage!
    dateTimes: MessageDateTimes!
    context: MessageContext!
}

"""An existing `messageId` in the `chatId` which was updated."""
type UpdatedMessage implements MessageData, BareMessage {
    chatId: Int!
    messageId: Int!
    sender: Account!
    text: TextMessage!
    dateTimes: MessageDateTimes!
    hasStar: Boolean!
    context: MessageContext!
}

type MessageDateTimes {
    sent: DateTime!
    statuses: [MessageDateTimeStatus!]!
}

"""The `dateTime` the `user` created the `status`."""
type MessageDateTimeStatus {
    user: Account!
    dateTime: DateTime!
    status: MessageStatus!
}

enum MessageStatus {
    DELIVERED
    READ
}

type TokenSet {
    accessToken: ID!
    refreshToken: ID!
}

input Login {
    username: Username!
    password: Password!
}

"""Only non-null fields will be updated."""
input AccountUpdate {
    username: Username
    password: Password
    emailAddress: String
    firstName: String
    lastName: String
    bio: Bio
}

input GroupChatInput {
    title: GroupChatTitle!
    description: GroupChatDescription!
    userIdList: [Int!]!
    adminIdList: [Int!]!
}