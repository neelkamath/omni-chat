"""Complies with ISO 8601."""
scalar DateTime

"""A cursor for pagination."""
scalar Cursor

"""A username which has non-whitespace characters, is less than 256 characters, and is lowercase."""
scalar Username

"""A password which contains non-whitespace characters."""
scalar Password

"""1-70 characters, of which at least one isn't whitespace."""
scalar GroupChatTitle

"""At most 1,000 characters. An empty string corresponds to no description."""
scalar GroupChatDescription

"""1-10,000 characters, of which at least one isn't whitespace."""
scalar TextMessage

"""
GraphQL mandates data be returned for every operation, and data be present in every type. However, certain operations
and types don't have relevant data. This type, which is an empty `String`, indicates such.
"""
scalar Placeholder

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

type Query {
    """
    Returns whether the user's account can be deleted. The only reason the account cannot be deleted is if the user is
    the admin of a group chat containing users other than themselves. In this case, they must first appoint a different
    user as the admin.

    You must send an access token with this request.
    """
    canDeleteAccount: Boolean!

    """
    Case-insensitively `query`s text messages in the `chatId`.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    You must send an access token with this request.
    """
    searchChatMessages(chatId: Int!, query: String!, last: Int, before: Cursor): [MessageEdge!]!

    """
    Case-insensitively `query`s every text message in every chat the user is in. Each item in the returned
    `ChatMessages` will be for a particular `ChatMessages.chat`, and have the `ChatMessages.messages` from the search
    results.

    You must send an access token with this request.
    """
    searchMessages(query: String!): [ChatMessages!]!

    """
    Returns the user's account info.

    You must send an access token with this request.
    """
    readAccount: Account!

    """Returns whether the `username` has been taken."""
    isUsernameTaken(username: Username!): Boolean!

    """Returns whether the `emailAddress` has been taken."""
    isEmailAddressTaken(emailAddress: String!): Boolean!

    """
    Returns the chats the user is in.

    You must send an access token with this request.
    """
    readChats: [Chat!]!

    """
    Returns the chat `id`.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"`.

    You must send an access token with this request.
    """
    readChat(id: Int!): Chat!

    """
    Case-insensitively searches group chats and private chats. Private chats are searched by matching the `query` with
    the username, first name, and last name of users the user has chats with. Group chats are searched by matching the
    `query` with the title of group chats the user is in.

    You must send an access token with this request.
    """
    searchChats(query: String!): [Chat!]!

    """
    Retrieves saved contacts.

    You must send an access token with this request.
    """
    readContacts(first: Int, after: Cursor): AccountsConnection!

    """
    Case-insensitively searches contacts using the `query`.

    You must send an access token with this request.
    """
    searchContacts(query: String!, first: Int, after: Cursor): AccountsConnection!

    """
    Operations such as `Query.updateAccount` require authentication via an access token. You can acquire one to
    authenticate the user by passing their `Login` to this operation.

    Returned `errors[0].message`s could be `"NONEXISTENT_USER"` (i.e., the username doesn't exist),
    `"UNVERIFIED_EMAIL_ADDRESS"`, or `"INCORRECT_PASSWORD"`.
    """
    requestTokenSet(login: Login!): TokenSet!

    """
    The access token is short-lived. Once it expires, the user would have to log in again. This can be avoided by
    passing the `refreshToken` to this operation to request a new set of tokens.
    """
    refreshTokenSet(refreshToken: ID!): TokenSet!

    """
    Searches users. The `query` is case-insensitively matched against users' usernames, email addresses, first names,
    and last names. Returns the users found.
    """
    searchUsers(query: String!, first: Int, after: Cursor): AccountsConnection!
}

type Mutation {
    """
    Deletes the user's account. Returns whether the account was deleted. Use `Query.canDeleteAccount` to check if you
    can delete the account.

    Returned `errors[0].message`s could be `"CANNOT_DELETE_ACCOUNT"`.

    You must send an access token with this request.
    """
    deleteAccount: Placeholder!

    """
    Lets the server know that the user has had the `messageId` delivered to them.

    Returned `errors[0].message`s could be `"INVALID_MESSAGE_ID"` (i.e., the message doesn't exist in a chat the user is
    in, or the message is the user's own), or `"DUPLICATE_STATUS"` (i.e., you have already told the server that the user
    has had the message delivered to them).

    You must send an access token with this request.
    """
    createDeliveredStatus(messageId: Int!): Placeholder!

    """
    Lets the server know that the user has read the message `id`. If you haven't told the server that the message was
    received (i.e., `Mutation.receiveMessage`), the delivery status will be created.

    Returned `errors[0].message`s could be `"INVALID_MESSAGE_ID"` (i.e., the message doesn't exist in a chat the user is
    in, or the message is the user's own), or `"DUPLICATE_STATUS"` (i.e., you have already told the server that the user
    has had the message delivered to them).

    You must send an access token with this request.
    """
    createReadStatus(messageId: Int!): Placeholder!

    """
    Updates the user's account. Only the non-null fields will be updated. Use `Query.isUsernameTaken` and
    `Query.isEmailAddressTaken` to see whether you can update the `AccountUpdate.username` and
    `AccountUpdate.emailAddress` fields to the requested ones respectively. None of the updates will take place if even
    one of the fields were invalid.

    Returned `errors[0].message`s could be `"USERNAME_TAKEN"`, or `"EMAIL_ADDRESS_TAKEN"`.

    You must send an access token with this request.
    """
    updateAccount(update: AccountUpdate!): Placeholder!

    """
    Creates an account, and sends the user a verification email. The user will not be allowed to log in until they
    verify their email address. Use `Query.isUsernameTaken` and `Query.isEmailAddressTaken` to see whether you can use
    the requested `NewAccount.username` and `NewAccount.emailAddress` fields respectively.

    Returned `errors[0].message`s could be `"USERNAME_TAKEN"`, or `"EMAIL_ADDRESS_TAKEN"`.
    """
    createAccount(account: NewAccount!): Placeholder!

    """
    Sends the user an email to verify their email `address`. For example, the user may want the email verification to be
    resent because the one which was automatically sent when their account was created timed out. Use
    `Query.isEmailAddressTaken` to check whether the supplied `email` address exists.

    Returned `errors[0].message`s could be `"UNREGISTERED_EMAIL_ADDRESS"`.
    """
    sendEmailAddressVerification(emailAddress: String!): Placeholder!

    """
    Sends a password reset email to the supplied `address`. Use `Query.isEmailAddressTaken` to check whether the
    supplied `address` address exists. If the user is logged in (i.e., you have an access token), and wants to update
    their password, you should use `Mutation.updateAccount` instead.

    Returned `errors[0].message`s could be `"UNREGISTERED_EMAIL_ADDRESS"`.
    """
    resetPassword(emailAddress: String!): Placeholder!

    """
    Leaves the group chat.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat), or
    `"ADMIN_CANNOT_LEAVE"` (i.e., the user is the admin, and they aren't the last user in the chat, so they can't leave
    without transferring the admin status first).

    You must send an access token with this request.
    """
    leaveGroupChat(chatId: Int!): Placeholder!

    """
    Updates a group chat. Only the admin can update it. Only non-null fields will be updated.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't the chat), `"INVALID_GROUP_CHAT"`
    (i.e., the lists of users to add and remove both contained the same user ID), `"INVALID_USER_ID"` (i.e., a user to
    be added to the chat doesn't exist), or `"INVALID_NEW_ADMIN_ID"` (i.e., the to-be admin isn't in the chat).

    You must send an access token with this request.
    """
    updateGroupChat(update: GroupChatUpdate!): Placeholder!

    """
    Creates a group chat. Returns the new chat's ID.

    Returned `errors[0].message`s could be `"INVALID_USER_ID"` (i.e., one of the participants' IDs don't exist).

    You must send an access token with this request.
    """
    createGroupChat(chat: NewGroupChat!): Int!

    """
    Deletes a private chat.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    You must send an access token with this request.
    """
    deletePrivateChat(chatId: Int!): Placeholder!

    """
    Creates a private chat with the `userId`. Returns the chat's ID.

    Returned `errors[0].message`s could be `"CHAT_EXISTS"`, or `"INVALID_USER_ID"` (i.e., the specified user doesn't
    exist).

    You must send an access token with this request.
    """
    createPrivateChat(userId: ID!): Int!

    """
    Sends a message in a chat. Use `Subscription.subscribeToMessages` to get the message's ID and sending
    `scalar.DateTime`.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    You must send an access token with this request.
    """
    createMessage(chatId: Int!, text: TextMessage!): Placeholder!

    """
    Deletes the message `id` from the chat it's from. The user can only delete their own messages.

    Returned `errors[0].message`s could be `"INVALID_MESSAGE_ID"` (i.e., the message isn't in a chat the user is in, the
    message isn't visible to the user because they deleted the private chat, or the message isn't the user's own).

    You must send an access token with this request.
    """
    deleteMessage(id: Int!): Placeholder!

    """
    Remove saved contacts. Invalid contacts (e.g., invalid user IDs, unsaved contacts) will be ignored.

    You must send an access token with this request.
    """
    deleteContacts(userIdList: [String!]!): Placeholder!

    """
    Saves contacts. Contacts previously saved will be ignored. If the user's own contact is present, it will be ignored.
    Existing contacts will be ignored.

    Returned `errors[0].message`s could be `"INVALID_CONTACT"` (i.e., one of the user IDs didn't exist).

    You must send an access token with this request.
    """
    createContacts(userIdList: [String!]!): Placeholder!
}

type Subscription {
    """
    Yields created and deleted messages (including your own) in the `chatId`. The subscription will be stopped if the
    chat was deleted, or the user deleted their account.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    You must send an access token with this request.
    """
    subscribeToMessages(chatId: Int!): MessagesSubscription!

    """
    Yields updates on the user's contacts. The subscription will be stopped if the user deletes their account. The
    subscription will be stopped if the user deletes their account.

    You must send an access token with this request.
    """
    subscribeToContacts: ContactsSubscription!

    """
    Yields the other user's account when they update it. The subscription will be stopped if one of the users in the
    chat deletes their account, or if the user deletes the chat.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    You must send an access token with this request.
    """
    subscribeToPrivateChatInfo(chatId: Int!): PrivateChatInfoSubscription!

    """
    Yields updates on a group chat's metadata. The subscription will be stopped if the user deletes their account, or
    leaves the chat.

    Returned `errors[0].message`s could be `"INVALID_CHAT_ID"` (i.e., the user isn't in the chat).

    You must send an access token with this request.
    """
    subscribeToGroupChatInfo(chatId: Int!): GroupChatInfoSubscription!

    """
    Yields group chats the user was added to. The subscription will be stopped if the user deletes their account.

    You must send an access token with this request.
    """
    subscribeToNewGroupChats: NewGroupChatsSubscription!
}

"""Represents created and deleted messages, deleted chats, and the subscription creation status."""
union MessagesSubscription = CreatedSubscription
    | DeletedMessage
    | DeletionOfEveryMessage
    | NewMessage
    | UpdatedMessage
    | MessageDeletionPoint
    | UserChatMessagesRemoval

union ContactsSubscription = CreatedSubscription | NewContact | UpdatedContact | DeletedContact

"""An `UpdatedAccount` represents the account of the other user in the chat when it's updated."""
union PrivateChatInfoSubscription = CreatedSubscription | UpdatedAccount

"""
An `UpdatedAccount` represents the account of a user in the chat which has been updated. The subscriber's account
updates will also be included.

An `ExitedUser` will not be sent if the subscriber has exited.
"""
union GroupChatInfoSubscription = CreatedSubscription | UpdatedGroupChat | UpdatedAccount | ExitedUser

"""A `GroupChat` represents a chat the user was added to, including a chat the user just made."""
union NewGroupChatsSubscription = CreatedSubscription | GroupChat

"""The `id` of a user who left the group chat."""
type ExitedUser {
    id: ID!
}

type UpdatedAccount {
    username: Username!
    emailAddress: String!
    firstName: String
    lastName: String
}

"""
A group chat which had its metadata updated. null fields haven't been updated. The previous data may be sent again
(e.g., `adminId` may still be the previous admin's ID).
"""
type UpdatedGroupChat {
    title: GroupChatTitle
    description: GroupChatDescription
    newUsers: [Account!]
    removedUsers: [Account!]
    adminId: String
}

"""
Every message in the chat has been deleted.

This happens in private chats when the user deleted it, or the other user deleted their account. This happens in group
chats when the last user left the chat.
"""
type DeletionOfEveryMessage {
    placeholder: Placeholder!
}

"""
Every message the `userId` sent in the chat has been deleted. This happens when a group chat's member deletes their
account.
"""
type UserChatMessagesRemoval {
    userId: ID!
}

"""
Indicates that the `Subscription` has been created. This will only be sent only once, and will be the first event sent.
"""
type CreatedSubscription {
    placeholder: Placeholder!
}

"""Indicates that the every message `until` the `DateTime` has been deleted."""
type MessageDeletionPoint {
    until: DateTime!
}

type DeletedMessage {
    id: Int!
}

type AccountsConnection {
    edges: [AccountEdge!]!
    pageInfo: PageInfo!
}

type AccountEdge {
    node: Account!
    cursor: Cursor!
}

interface AccountData {
    id: ID!
    username: Username!
    emailAddress: String!
    firstName: String
    lastName: String
}

type Account implements AccountData {
    id: ID!
    username: Username!
    emailAddress: String!
    firstName: String
    lastName: String
}

type NewContact implements AccountData {
    id: ID!
    username: Username!
    emailAddress: String!
    firstName: String
    lastName: String
}

type UpdatedContact implements AccountData {
    id: ID!
    username: Username!
    emailAddress: String!
    firstName: String
    lastName: String
}

"""
The `id` of the contact which has been deleted for the user. This happens when the user deletes a contact, or the
contact's account gets deleted.
"""
type DeletedContact {
    id: ID!
}

input NewAccount {
    """Must be lowercase."""
    username: Username!
    password: Password!
    emailAddress: String!
    firstName: String
    lastName: String
}

type ChatMessages {
    chat: Chat!
    messages(last: Int, before: Cursor): [MessageEdge!]!
}

interface Chat {
    id: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
}

type MessagesConnection {
    edges: [MessageEdge!]!
    pageInfo: PageInfo!
}

type MessageEdge {
    node: Message!
    cursor: Cursor!
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: Cursor
    endCursor: Cursor
}

type GroupChat implements Chat {
    id: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
    title: GroupChatTitle!
    description: GroupChatDescription
    """The ID of the admin present who is present in the `users`."""
    adminId: ID!
    users(first: Int, after: Cursor): AccountsConnection!
}

type PrivateChat implements Chat {
    id: Int!
    messages(last: Int, before: Cursor): MessagesConnection!
    """The user being chatted with."""
    user: Account!
}

interface MessageData {
    id: Int!
    sender: Account!
    text: TextMessage!
    dateTimes: MessageDateTimes!
}

type Message {
    id: Int!
    sender: Account!
    text: TextMessage!
    dateTimes: MessageDateTimes!
}

type NewMessage implements MessageData {
    id: Int!
    sender: Account!
    text: TextMessage!
    dateTimes: MessageDateTimes!
}

"""A message which was previously sent was updated."""
type UpdatedMessage implements MessageData {
    id: Int!
    sender: Account!
    text: TextMessage!
    dateTimes: MessageDateTimes!
}

type MessageDateTimes {
    sent: DateTime!
    statuses: [MessageDateTimeStatus!]!
}

"""The `dateTime` the `user` created the `status`."""
type MessageDateTimeStatus {
    user: Account!
    dateTime: DateTime!
    status: MessageStatus!
}

enum MessageStatus {
    DELIVERED
    READ
}

type TokenSet {
    accessToken: ID!
    refreshToken: ID!
}

input Login {
    username: Username!
    password: Password!
}

input AccountUpdate {
    username: Username
    password: Password
    emailAddress: String
    firstName: String
    lastName: String
}

input GroupChatUpdate {
    chatId: Int!
    title: GroupChatTitle
    description: GroupChatDescription
    """The ID of every new user to add."""
    newUserIdList: [String!]
    """The ID of every user to remove."""
    removedUserIdList: [String!]
    """Transfers the admin status to the specified user ID."""
    newAdminId: ID
}

input NewGroupChat {
    title: GroupChatTitle!
    description: GroupChatDescription!
    userIdList: [String!]!
}